<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>UQTk: Uncertainty Quantification Toolkit: PCSet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">UQTk: Uncertainty Quantification Toolkit
   &#160;<span id="projectnumber">2.1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classPCSet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PCSet Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines and initializes PC basis function set and provides functions to manipulate PC expansions defined on this basis set.  
 <a href="classPCSet.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PCSet_8h_source.html">PCSet.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a39330e506c58cbd1463b9c708b189f0b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a39330e506c58cbd1463b9c708b189f0b">PCSet</a> (const string sp_type, const int order, const int n_dim, const string pc_type, const double alpha=0.0, const double betta=1.0)</td></tr>
<tr class="memdesc:a39330e506c58cbd1463b9c708b189f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor: initializes the PC basis set for the order, number of dimensions and type that are passed in.  <a href="#a39330e506c58cbd1463b9c708b189f0b">More...</a><br/></td></tr>
<tr class="separator:a39330e506c58cbd1463b9c708b189f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fd6a1bc00f546367cdfec248823306"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ac8fd6a1bc00f546367cdfec248823306">PCSet</a> (const string sp_type, const <a class="el" href="classArray1D.html">Array1D</a>&lt; int &gt; &amp;maxOrders, const int n_dim, const string pc_type, const double alpha=0.0, const double betta=1.0)</td></tr>
<tr class="memdesc:ac8fd6a1bc00f546367cdfec248823306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor: initializes the PC basis set ordered in an HDMR fashion given order per each HDMR rank (univariate, bivariate, etc...)  <a href="#ac8fd6a1bc00f546367cdfec248823306">More...</a><br/></td></tr>
<tr class="separator:ac8fd6a1bc00f546367cdfec248823306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d1ad460b6a6aa5b44ccfaec70ac6c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a52d1ad460b6a6aa5b44ccfaec70ac6c5">PCSet</a> (const string sp_type, const <a class="el" href="classArray2D.html">Array2D</a>&lt; int &gt; &amp;customMultiIndex, const string pc_type, const double alpha=0.0, const double betta=1.0)</td></tr>
<tr class="memdesc:a52d1ad460b6a6aa5b44ccfaec70ac6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor: initializes the PC basis set for a given custom multiIndex.  <a href="#a52d1ad460b6a6aa5b44ccfaec70ac6c5">More...</a><br/></td></tr>
<tr class="separator:a52d1ad460b6a6aa5b44ccfaec70ac6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a3131cfebaca370b11fb9eb67f78e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ac1a3131cfebaca370b11fb9eb67f78e8">~PCSet</a> ()</td></tr>
<tr class="memdesc:ac1a3131cfebaca370b11fb9eb67f78e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor: cleans up all memory and destroys object.  <a href="#ac1a3131cfebaca370b11fb9eb67f78e8">More...</a><br/></td></tr>
<tr class="separator:ac1a3131cfebaca370b11fb9eb67f78e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993d6c600aad5e25e0e0311598cbc047"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a993d6c600aad5e25e0e0311598cbc047">SetQuadRule</a> (const string grid_type, const string fs_type, int param)</td></tr>
<tr class="memdesc:a993d6c600aad5e25e0e0311598cbc047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the quadrature rule.  <a href="#a993d6c600aad5e25e0e0311598cbc047">More...</a><br/></td></tr>
<tr class="separator:a993d6c600aad5e25e0e0311598cbc047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78695a97e980e969d969e291e596d0f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a78695a97e980e969d969e291e596d0f7">SetQuadRule</a> (<a class="el" href="classQuad.html">Quad</a> &amp;quadRule)</td></tr>
<tr class="memdesc:a78695a97e980e969d969e291e596d0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a custom quadrature rule by pointing to the corresponding object.  <a href="#a78695a97e980e969d969e291e596d0f7">More...</a><br/></td></tr>
<tr class="separator:a78695a97e980e969d969e291e596d0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82dcd8d6b29fa0b4916e80f6a9b2d32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ae82dcd8d6b29fa0b4916e80f6a9b2d32">PrintMultiIndex</a> () const </td></tr>
<tr class="memdesc:ae82dcd8d6b29fa0b4916e80f6a9b2d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print information on the screen.  <a href="#ae82dcd8d6b29fa0b4916e80f6a9b2d32">More...</a><br/></td></tr>
<tr class="separator:ae82dcd8d6b29fa0b4916e80f6a9b2d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adebba2900a8ab2320c5f022bd97077be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#adebba2900a8ab2320c5f022bd97077be">PrintMultiIndexNormSquared</a> () const </td></tr>
<tr class="memdesc:adebba2900a8ab2320c5f022bd97077be"><td class="mdescLeft">&#160;</td><td class="mdescRight">For all terms, print their multi-index and norm^2 on the screen.  <a href="#adebba2900a8ab2320c5f022bd97077be">More...</a><br/></td></tr>
<tr class="separator:adebba2900a8ab2320c5f022bd97077be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9229dd305d9f71ff4b1a0e6dbd22be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#adf9229dd305d9f71ff4b1a0e6dbd22be">GetMultiIndex</a> (<a class="el" href="classArray2D.html">Array2D</a>&lt; int &gt; &amp;mindex) const </td></tr>
<tr class="memdesc:adf9229dd305d9f71ff4b1a0e6dbd22be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get and set variables/arrays inline.  <a href="#adf9229dd305d9f71ff4b1a0e6dbd22be">More...</a><br/></td></tr>
<tr class="separator:adf9229dd305d9f71ff4b1a0e6dbd22be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef80e902457132ce7ea94ccc78b64ea4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#aef80e902457132ce7ea94ccc78b64ea4">GetNormSq</a> (<a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;normsq) const </td></tr>
<tr class="memdesc:aef80e902457132ce7ea94ccc78b64ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the norm-squared.  <a href="#aef80e902457132ce7ea94ccc78b64ea4">More...</a><br/></td></tr>
<tr class="separator:aef80e902457132ce7ea94ccc78b64ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9de62b98a30f02ca047090c1fa505a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a7d9de62b98a30f02ca047090c1fa505a">GetNumberPCTerms</a> () const </td></tr>
<tr class="memdesc:a7d9de62b98a30f02ca047090c1fa505a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of terms in a PC expansion of this order and dimension.  <a href="#a7d9de62b98a30f02ca047090c1fa505a">More...</a><br/></td></tr>
<tr class="separator:a7d9de62b98a30f02ca047090c1fa505a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669e201ab07ab7eac6dc308094e566e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a669e201ab07ab7eac6dc308094e566e4">GetNDim</a> () const </td></tr>
<tr class="memdesc:a669e201ab07ab7eac6dc308094e566e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the PC dimensionality.  <a href="#a669e201ab07ab7eac6dc308094e566e4">More...</a><br/></td></tr>
<tr class="separator:a669e201ab07ab7eac6dc308094e566e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142e3f81b5baa75ed7a7276d3917897f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a142e3f81b5baa75ed7a7276d3917897f">GetOrder</a> () const </td></tr>
<tr class="memdesc:a142e3f81b5baa75ed7a7276d3917897f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the PC order.  <a href="#a142e3f81b5baa75ed7a7276d3917897f">More...</a><br/></td></tr>
<tr class="separator:a142e3f81b5baa75ed7a7276d3917897f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd3aad6872dd08178f28bca1f430839"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#afbd3aad6872dd08178f28bca1f430839">GetNQuadPoints</a> () const </td></tr>
<tr class="memdesc:afbd3aad6872dd08178f28bca1f430839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of quadrature points.  <a href="#afbd3aad6872dd08178f28bca1f430839">More...</a><br/></td></tr>
<tr class="separator:afbd3aad6872dd08178f28bca1f430839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301434bdc272029f5891e4963b706824"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a301434bdc272029f5891e4963b706824">GetQuadPoints</a> (<a class="el" href="classArray2D.html">Array2D</a>&lt; double &gt; &amp;quad) const </td></tr>
<tr class="memdesc:a301434bdc272029f5891e4963b706824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the quadrature points.  <a href="#a301434bdc272029f5891e4963b706824">More...</a><br/></td></tr>
<tr class="separator:a301434bdc272029f5891e4963b706824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe0c28f6527f8f35bf48e217cf7a0a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a9fe0c28f6527f8f35bf48e217cf7a0a9">GetQuadPointsWeights</a> (<a class="el" href="classArray2D.html">Array2D</a>&lt; double &gt; &amp;quad, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;wghts) const </td></tr>
<tr class="memdesc:a9fe0c28f6527f8f35bf48e217cf7a0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the quadrature points and weights.  <a href="#a9fe0c28f6527f8f35bf48e217cf7a0a9">More...</a><br/></td></tr>
<tr class="separator:a9fe0c28f6527f8f35bf48e217cf7a0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade53ff486c307f98b50b67242157e53f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ade53ff486c307f98b50b67242157e53f">GetQuadPoints</a> (double *quad) const </td></tr>
<tr class="memdesc:ade53ff486c307f98b50b67242157e53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the quadrature points folded into a one-dimensional array quad.  <a href="#ade53ff486c307f98b50b67242157e53f">More...</a><br/></td></tr>
<tr class="separator:ade53ff486c307f98b50b67242157e53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9094c7385347b93131333a6d29e58c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#aac9094c7385347b93131333a6d29e58c">GetQuadWeights</a> (<a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;wghts) const </td></tr>
<tr class="memdesc:aac9094c7385347b93131333a6d29e58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the quadrature weights.  <a href="#aac9094c7385347b93131333a6d29e58c">More...</a><br/></td></tr>
<tr class="separator:aac9094c7385347b93131333a6d29e58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bcba8c30387c5a840771e62a46c2a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a76bcba8c30387c5a840771e62a46c2a5">GetQuadWeights</a> (double *wghts) const </td></tr>
<tr class="memdesc:a76bcba8c30387c5a840771e62a46c2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the quadrature weights folded into a one-dimensional array wghts.  <a href="#a76bcba8c30387c5a840771e62a46c2a5">More...</a><br/></td></tr>
<tr class="separator:a76bcba8c30387c5a840771e62a46c2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d584fff60be4daad2f807c86486d5b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a7d584fff60be4daad2f807c86486d5b5">GetPsi</a> (<a class="el" href="classArray2D.html">Array2D</a>&lt; double &gt; &amp;psi) const </td></tr>
<tr class="memdesc:a7d584fff60be4daad2f807c86486d5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the values of the basis polynomials evaluated at the quadrature points.  <a href="#a7d584fff60be4daad2f807c86486d5b5">More...</a><br/></td></tr>
<tr class="separator:a7d584fff60be4daad2f807c86486d5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927caa3132a7584b8dafe676a7e91cd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a927caa3132a7584b8dafe676a7e91cd9">GetPsi</a> (double *psi) const </td></tr>
<tr class="memdesc:a927caa3132a7584b8dafe676a7e91cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the polynomials evaluated at the quadrature points folded into a one-dimensional array psi.  <a href="#a927caa3132a7584b8dafe676a7e91cd9">More...</a><br/></td></tr>
<tr class="separator:a927caa3132a7584b8dafe676a7e91cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652f515895963a080e436d062c839490"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a652f515895963a080e436d062c839490">GetPsiSq</a> (<a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;psisq) const </td></tr>
<tr class="memdesc:a652f515895963a080e436d062c839490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the basis polynomial norms-squared in an array class object psisq.  <a href="#a652f515895963a080e436d062c839490">More...</a><br/></td></tr>
<tr class="separator:a652f515895963a080e436d062c839490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f1c9e841ae254eff8f74a50d650443"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a67f1c9e841ae254eff8f74a50d650443">GetPsiSq</a> (double *psisq) const </td></tr>
<tr class="memdesc:a67f1c9e841ae254eff8f74a50d650443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the basis polynomial norms-squared in a double* array psisq.  <a href="#a67f1c9e841ae254eff8f74a50d650443">More...</a><br/></td></tr>
<tr class="separator:a67f1c9e841ae254eff8f74a50d650443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7197a5164e9c3dbd549d76cdaab7b21a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a7197a5164e9c3dbd549d76cdaab7b21a">GetTaylorTolerance</a> () const </td></tr>
<tr class="memdesc:a7197a5164e9c3dbd549d76cdaab7b21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get relative tolerance for Taylor series approximations.  <a href="#a7197a5164e9c3dbd549d76cdaab7b21a">More...</a><br/></td></tr>
<tr class="separator:a7197a5164e9c3dbd549d76cdaab7b21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00882eff713add35201706e2db6a9f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ae00882eff713add35201706e2db6a9f4">SetTaylorTolerance</a> (const double &amp;rTol)</td></tr>
<tr class="memdesc:ae00882eff713add35201706e2db6a9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set relative tolerance for Taylor series approximations.  <a href="#ae00882eff713add35201706e2db6a9f4">More...</a><br/></td></tr>
<tr class="separator:ae00882eff713add35201706e2db6a9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919ea124540fcbc82b851235eefe3e99"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a919ea124540fcbc82b851235eefe3e99">GetTaylorTermsMax</a> () const </td></tr>
<tr class="memdesc:a919ea124540fcbc82b851235eefe3e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum number of terms in Taylor series approximations.  <a href="#a919ea124540fcbc82b851235eefe3e99">More...</a><br/></td></tr>
<tr class="separator:a919ea124540fcbc82b851235eefe3e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7611a9a35ddac33913c953ed155b295"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ae7611a9a35ddac33913c953ed155b295">SetTaylorTermsMax</a> (const int &amp;maxTerm)</td></tr>
<tr class="memdesc:ae7611a9a35ddac33913c953ed155b295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum number of terms in Taylor series approximations.  <a href="#ae7611a9a35ddac33913c953ed155b295">More...</a><br/></td></tr>
<tr class="separator:ae7611a9a35ddac33913c953ed155b295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb11850dfc7aaa0066f1dd84c1593378"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#adb11850dfc7aaa0066f1dd84c1593378">SetLogCompMethod</a> (const <a class="el" href="PCSet_8h.html#a7ec503935215c038c44ef9fe72d08618">LogCompMethod</a> &amp;logMethod)</td></tr>
<tr class="memdesc:adb11850dfc7aaa0066f1dd84c1593378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set method of computing the log function.  <a href="#adb11850dfc7aaa0066f1dd84c1593378">More...</a><br/></td></tr>
<tr class="separator:adb11850dfc7aaa0066f1dd84c1593378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4d605c58d5b049c9545bfe8b844457"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a6d4d605c58d5b049c9545bfe8b844457">GetGMRESDivTolerance</a> () const </td></tr>
<tr class="memdesc:a6d4d605c58d5b049c9545bfe8b844457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get relative tolerance for GMRES in Div routine.  <a href="#a6d4d605c58d5b049c9545bfe8b844457">More...</a><br/></td></tr>
<tr class="separator:a6d4d605c58d5b049c9545bfe8b844457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8756858e2aa2168e9f0b38aa180d15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a0b8756858e2aa2168e9f0b38aa180d15">SetGMRESDivTolerance</a> (const double &amp;rTol)</td></tr>
<tr class="memdesc:a0b8756858e2aa2168e9f0b38aa180d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the relative tolerance for GMRES in Div routine.  <a href="#a0b8756858e2aa2168e9f0b38aa180d15">More...</a><br/></td></tr>
<tr class="separator:a0b8756858e2aa2168e9f0b38aa180d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f5b2268e4d85e9aa9e139abbbc1192"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#af8f5b2268e4d85e9aa9e139abbbc1192">InitMeanStDv</a> (const double &amp;m, const double &amp;s, double *p) const </td></tr>
<tr class="memdesc:af8f5b2268e4d85e9aa9e139abbbc1192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrusive arithmetics.  <a href="#af8f5b2268e4d85e9aa9e139abbbc1192">More...</a><br/></td></tr>
<tr class="separator:af8f5b2268e4d85e9aa9e139abbbc1192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfc15c02421cffee65a6c491cf15e0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a0dfc15c02421cffee65a6c491cf15e0a">InitMeanStDv</a> (const double &amp;m, const double &amp;s, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p) const </td></tr>
<tr class="memdesc:a0dfc15c02421cffee65a6c491cf15e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a PC expansion p in <a class="el" href="classArray1D.html">Array1D&lt;double&gt;</a> format to have the same distribution as the underlying PC germ, but with a specified mean m and standard deviation s.  <a href="#a0dfc15c02421cffee65a6c491cf15e0a">More...</a><br/></td></tr>
<tr class="separator:a0dfc15c02421cffee65a6c491cf15e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806404a8a865705943171ad1ecbe599c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a806404a8a865705943171ad1ecbe599c">Copy</a> (double *p1, const double *p2) const </td></tr>
<tr class="memdesc:a806404a8a865705943171ad1ecbe599c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy PC expansion p2 into p1 (i.e. p1 = p2).  <a href="#a806404a8a865705943171ad1ecbe599c">More...</a><br/></td></tr>
<tr class="separator:a806404a8a865705943171ad1ecbe599c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24c31c6032268cc3a4a4c6cea263113"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ad24c31c6032268cc3a4a4c6cea263113">Copy</a> (<a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p1, const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p2) const </td></tr>
<tr class="memdesc:ad24c31c6032268cc3a4a4c6cea263113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy PC expansion p2 into p1 (i.e. p1 = p2).  <a href="#ad24c31c6032268cc3a4a4c6cea263113">More...</a><br/></td></tr>
<tr class="separator:ad24c31c6032268cc3a4a4c6cea263113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bd139f0cf496b196fd3b8025f6aff9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#af6bd139f0cf496b196fd3b8025f6aff9">Add</a> (const double *p1, const double *p2, double *p3) const </td></tr>
<tr class="memdesc:af6bd139f0cf496b196fd3b8025f6aff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two PC expansions given by double* arguments p1 and p2, and return the result in p3.  <a href="#af6bd139f0cf496b196fd3b8025f6aff9">More...</a><br/></td></tr>
<tr class="separator:af6bd139f0cf496b196fd3b8025f6aff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111d6a52a3146aebb8a279156db4be2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a111d6a52a3146aebb8a279156db4be2d">Add</a> (const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p1, const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p2, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p3) const </td></tr>
<tr class="memdesc:a111d6a52a3146aebb8a279156db4be2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two PC expansions given by <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> arguments p1 and p2, and return the result in p3.  <a href="#a111d6a52a3146aebb8a279156db4be2d">More...</a><br/></td></tr>
<tr class="separator:a111d6a52a3146aebb8a279156db4be2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86122d77c17ed1eaac2db707437fad8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ae86122d77c17ed1eaac2db707437fad8">AddInPlace</a> (double *p1, const double *p2) const </td></tr>
<tr class="memdesc:ae86122d77c17ed1eaac2db707437fad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add PC expansions given by double* argument p2 to p1 and return the result in p1.  <a href="#ae86122d77c17ed1eaac2db707437fad8">More...</a><br/></td></tr>
<tr class="separator:ae86122d77c17ed1eaac2db707437fad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ad18576354c5990199fe7584b07b53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ae7ad18576354c5990199fe7584b07b53">AddInPlace</a> (<a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p1, const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p2) const </td></tr>
<tr class="memdesc:ae7ad18576354c5990199fe7584b07b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add PC expansions given by <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p2 to p1 and return the result in p1.  <a href="#ae7ad18576354c5990199fe7584b07b53">More...</a><br/></td></tr>
<tr class="separator:ae7ad18576354c5990199fe7584b07b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544ea1907eedb7a9fde90d5e0811d071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a544ea1907eedb7a9fde90d5e0811d071">Multiply</a> (const double *p1, const double &amp;a, double *p2) const </td></tr>
<tr class="memdesc:a544ea1907eedb7a9fde90d5e0811d071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply PC expansion p1 with scalar a and return the result in p2. All PCEs are in double* format.  <a href="#a544ea1907eedb7a9fde90d5e0811d071">More...</a><br/></td></tr>
<tr class="separator:a544ea1907eedb7a9fde90d5e0811d071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0854bfa5e07dd64ee8faef4f5c620e39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a0854bfa5e07dd64ee8faef4f5c620e39">Multiply</a> (const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p1, const double &amp;a, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p2) const </td></tr>
<tr class="memdesc:a0854bfa5e07dd64ee8faef4f5c620e39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply PC expansion p1 with scalar a and return the result in p2. All PCEs are in <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> format.  <a href="#a0854bfa5e07dd64ee8faef4f5c620e39">More...</a><br/></td></tr>
<tr class="separator:a0854bfa5e07dd64ee8faef4f5c620e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5796339475eeac74f4233100ada3ae3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a5796339475eeac74f4233100ada3ae3b">MultiplyInPlace</a> (double *p1, const double &amp;a) const </td></tr>
<tr class="memdesc:a5796339475eeac74f4233100ada3ae3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply PC expansions given by double* argument p1 with scalar a and return the result in p1.  <a href="#a5796339475eeac74f4233100ada3ae3b">More...</a><br/></td></tr>
<tr class="separator:a5796339475eeac74f4233100ada3ae3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4551a60a3de1135377beff722cc0f3b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a4551a60a3de1135377beff722cc0f3b3">MultiplyInPlace</a> (<a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p1, const double &amp;a) const </td></tr>
<tr class="memdesc:a4551a60a3de1135377beff722cc0f3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply PC expansions given by <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p1 with scalar a and return the result in p1.  <a href="#a4551a60a3de1135377beff722cc0f3b3">More...</a><br/></td></tr>
<tr class="separator:a4551a60a3de1135377beff722cc0f3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e0427bafd34e68cb55b966741780a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a09e0427bafd34e68cb55b966741780a5">Subtract</a> (const double *p1, const double *p2, double *p3) const </td></tr>
<tr class="memdesc:a09e0427bafd34e68cb55b966741780a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract PC expansion p2 from p1, and return the result in p3, with all arguments given as double*.  <a href="#a09e0427bafd34e68cb55b966741780a5">More...</a><br/></td></tr>
<tr class="separator:a09e0427bafd34e68cb55b966741780a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1792ca1daf265904f9c18f1a9859597a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a1792ca1daf265904f9c18f1a9859597a">Subtract</a> (const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p1, const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p2, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p3) const </td></tr>
<tr class="memdesc:a1792ca1daf265904f9c18f1a9859597a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract PC expansion p2 from p1, and return the result in p3, with all arguments given as <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> structures.  <a href="#a1792ca1daf265904f9c18f1a9859597a">More...</a><br/></td></tr>
<tr class="separator:a1792ca1daf265904f9c18f1a9859597a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a7d92d80badff89e479232b531b8bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ad3a7d92d80badff89e479232b531b8bb">SubtractInPlace</a> (double *p1, const double *p2) const </td></tr>
<tr class="memdesc:ad3a7d92d80badff89e479232b531b8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract PC expansion p2 from p1, and return the result in p1, with all arguments given as double*.  <a href="#ad3a7d92d80badff89e479232b531b8bb">More...</a><br/></td></tr>
<tr class="separator:ad3a7d92d80badff89e479232b531b8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269e4facd9387e1ad7cdfb2b9f64605a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a269e4facd9387e1ad7cdfb2b9f64605a">SubtractInPlace</a> (<a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p1, const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p2) const </td></tr>
<tr class="memdesc:a269e4facd9387e1ad7cdfb2b9f64605a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract PC expansion p2 from p1, and return the result in p1, with all arguments given as <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> structures.  <a href="#a269e4facd9387e1ad7cdfb2b9f64605a">More...</a><br/></td></tr>
<tr class="separator:a269e4facd9387e1ad7cdfb2b9f64605a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe35b9432ba5a7d112a7f6377f30a07f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#afe35b9432ba5a7d112a7f6377f30a07f">Prod</a> (const double *p1, const double *p2, double *p3) const </td></tr>
<tr class="memdesc:afe35b9432ba5a7d112a7f6377f30a07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two PC expansions given by double* arguments p1 and p2, and return the result in p3.  <a href="#afe35b9432ba5a7d112a7f6377f30a07f">More...</a><br/></td></tr>
<tr class="separator:afe35b9432ba5a7d112a7f6377f30a07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5527d93459cb8d756b094728890d24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ace5527d93459cb8d756b094728890d24">Prod</a> (const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p1, const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p2, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p3) const </td></tr>
<tr class="memdesc:ace5527d93459cb8d756b094728890d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multipy two PC expansions given by <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> arguments p1 and p2, and return the result in p3.  <a href="#ace5527d93459cb8d756b094728890d24">More...</a><br/></td></tr>
<tr class="separator:ace5527d93459cb8d756b094728890d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c402eb017c10844b0ae49e57ecf28b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a7c402eb017c10844b0ae49e57ecf28b2">Polyn</a> (const double *polycf, int npoly, const double *p1, double *p2) const </td></tr>
<tr class="memdesc:a7c402eb017c10844b0ae49e57ecf28b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a polynomial of PC that is given in double* argument p1. Polynomial coefficients are given in double* argument polycf of size npoly. The output PC is contained in double* argument p2.  <a href="#a7c402eb017c10844b0ae49e57ecf28b2">More...</a><br/></td></tr>
<tr class="separator:a7c402eb017c10844b0ae49e57ecf28b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676d08cc77c68365dbf59c62a29d6afe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a676d08cc77c68365dbf59c62a29d6afe">Polyn</a> (const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;polycf, const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p1, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p2) const </td></tr>
<tr class="memdesc:a676d08cc77c68365dbf59c62a29d6afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a polynomial of PC that is given by <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p1. Polynomial coefficients are given in the <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument polycf. The output PC is contained in <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p2.  <a href="#a676d08cc77c68365dbf59c62a29d6afe">More...</a><br/></td></tr>
<tr class="separator:a676d08cc77c68365dbf59c62a29d6afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5128f399c1944f7819556072889713f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a5128f399c1944f7819556072889713f1">PolynMulti</a> (const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;polycf, const <a class="el" href="classArray2D.html">Array2D</a>&lt; int &gt; &amp;mindex, const <a class="el" href="classArray2D.html">Array2D</a>&lt; double &gt; &amp;p1, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p2) const </td></tr>
<tr class="memdesc:a5128f399c1944f7819556072889713f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a multivariate polynomial of a set of PC inputs given by <a class="el" href="classArray2D.html" title="Stores data of any type T in a 2D array. ">Array2D</a> argument p1 (each column of p1 is a PC input). Polynomial coefficients are given in <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument polycf. Multiindex set for the multivariate polynomial is given in <a class="el" href="classArray2D.html" title="Stores data of any type T in a 2D array. ">Array2D</a> argument mindex. The output PC is contained in <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p2.  <a href="#a5128f399c1944f7819556072889713f1">More...</a><br/></td></tr>
<tr class="separator:a5128f399c1944f7819556072889713f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755d8e136a80e6f6630c0416851a1234"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a755d8e136a80e6f6630c0416851a1234">Exp</a> (const double *p1, double *p2) const </td></tr>
<tr class="memdesc:a755d8e136a80e6f6630c0416851a1234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the exp() of the PC expansion given by double* argument p1, and return the result in p2.  <a href="#a755d8e136a80e6f6630c0416851a1234">More...</a><br/></td></tr>
<tr class="separator:a755d8e136a80e6f6630c0416851a1234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac73e410463bfcbef9502e3639c4b45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#adac73e410463bfcbef9502e3639c4b45">Exp</a> (const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p1, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p2) const </td></tr>
<tr class="memdesc:adac73e410463bfcbef9502e3639c4b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the exp() of the PC expansion given by <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p1, and return the result in p2.  <a href="#adac73e410463bfcbef9502e3639c4b45">More...</a><br/></td></tr>
<tr class="separator:adac73e410463bfcbef9502e3639c4b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f56c6441c1fde48b8faebfe1c7a0cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a32f56c6441c1fde48b8faebfe1c7a0cd">Log</a> (const double *p1, double *p2) const </td></tr>
<tr class="memdesc:a32f56c6441c1fde48b8faebfe1c7a0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the natural logarithm log() of the PC expansion given by double* argument p1, and return the result in p2. The logarithm is evaluated either via Taylor series or via integration depending on the value of parameter logMethod_.  <a href="#a32f56c6441c1fde48b8faebfe1c7a0cd">More...</a><br/></td></tr>
<tr class="separator:a32f56c6441c1fde48b8faebfe1c7a0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33722bcc9a2f8d363e75dabf2bad47f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ab33722bcc9a2f8d363e75dabf2bad47f">Log</a> (const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p1, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p2) const </td></tr>
<tr class="memdesc:ab33722bcc9a2f8d363e75dabf2bad47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the natural logarithm, log(), of the PC expansion given by <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p1, and return the result in <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p2.  <a href="#ab33722bcc9a2f8d363e75dabf2bad47f">More...</a><br/></td></tr>
<tr class="separator:ab33722bcc9a2f8d363e75dabf2bad47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cce271d6bacfc5f8b9d981da201e34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#af3cce271d6bacfc5f8b9d981da201e34">Log10</a> (const double *p1, double *p2) const </td></tr>
<tr class="memdesc:af3cce271d6bacfc5f8b9d981da201e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the logarithm to base 10 of the PC expansion given by double* argument p1, and return the result in p2.  <a href="#af3cce271d6bacfc5f8b9d981da201e34">More...</a><br/></td></tr>
<tr class="separator:af3cce271d6bacfc5f8b9d981da201e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1364fc8265d71c6ac6edc4df480acd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ab1364fc8265d71c6ac6edc4df480acd2">Log10</a> (const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p1, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p2) const </td></tr>
<tr class="memdesc:ab1364fc8265d71c6ac6edc4df480acd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the logarithm to base 10 of the PC expansion given by <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p1, and return the result in <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p2.  <a href="#ab1364fc8265d71c6ac6edc4df480acd2">More...</a><br/></td></tr>
<tr class="separator:ab1364fc8265d71c6ac6edc4df480acd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209f150f95d36b398b5e6e6b5f6cb1c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a209f150f95d36b398b5e6e6b5f6cb1c4">RPow</a> (const double *p1, double *p2, const double &amp;a) const </td></tr>
<tr class="memdesc:a209f150f95d36b398b5e6e6b5f6cb1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate power a (a real number) of PC expansion given by double* argument p1, and return the result in p2. The power is computed as p1^a = exp(a*log(p1)), where log(p1) is evaluated either via Taylor series or via integration depending on the value of parameter logMethod_.  <a href="#a209f150f95d36b398b5e6e6b5f6cb1c4">More...</a><br/></td></tr>
<tr class="separator:a209f150f95d36b398b5e6e6b5f6cb1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace215153ae1f103c3efc8a95e9ab3bd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ace215153ae1f103c3efc8a95e9ab3bd7">RPow</a> (const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p1, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p2, const double &amp;a) const </td></tr>
<tr class="memdesc:ace215153ae1f103c3efc8a95e9ab3bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate power a (a real number) of PC expansion given by <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p1, and return the result in <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p2.  <a href="#ace215153ae1f103c3efc8a95e9ab3bd7">More...</a><br/></td></tr>
<tr class="separator:ace215153ae1f103c3efc8a95e9ab3bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ab2f1557b7969e3d1ababf09ae6711"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a38ab2f1557b7969e3d1ababf09ae6711">IPow</a> (const double *p1, double *p2, const int &amp;ia) const </td></tr>
<tr class="memdesc:a38ab2f1557b7969e3d1ababf09ae6711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate power ia (an integer number) of PC expansion given by double* argument p1, and return the result in p2.  <a href="#a38ab2f1557b7969e3d1ababf09ae6711">More...</a><br/></td></tr>
<tr class="separator:a38ab2f1557b7969e3d1ababf09ae6711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79561ddc292cb669e72257b546ca5730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a79561ddc292cb669e72257b546ca5730">IPow</a> (const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p1, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p2, const int &amp;ia) const </td></tr>
<tr class="memdesc:a79561ddc292cb669e72257b546ca5730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate power ia (an integer number) of PC expansion given by <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p1, and return the result in <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p2.  <a href="#a79561ddc292cb669e72257b546ca5730">More...</a><br/></td></tr>
<tr class="separator:a79561ddc292cb669e72257b546ca5730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9472efb3ed768295727db014f9064191"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a9472efb3ed768295727db014f9064191">Inv</a> (const double *p1, double *p2) const </td></tr>
<tr class="memdesc:a9472efb3ed768295727db014f9064191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the inverse of PC expansion given by double* argument p1, and return the result in p2. The inverse is computed using the division function.  <a href="#a9472efb3ed768295727db014f9064191">More...</a><br/></td></tr>
<tr class="separator:a9472efb3ed768295727db014f9064191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f97d12860187f9c66a27afdb67b4fd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a2f97d12860187f9c66a27afdb67b4fd2">Inv</a> (const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p1, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p2) const </td></tr>
<tr class="memdesc:a2f97d12860187f9c66a27afdb67b4fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the inverse of PC expansion given by <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p1, and return the result in <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p2.  <a href="#a2f97d12860187f9c66a27afdb67b4fd2">More...</a><br/></td></tr>
<tr class="separator:a2f97d12860187f9c66a27afdb67b4fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6973a234d43c6216d3598e275d3cf96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#aa6973a234d43c6216d3598e275d3cf96">Div</a> (const double *p1, const double *p2, double *p3) const </td></tr>
<tr class="memdesc:aa6973a234d43c6216d3598e275d3cf96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide the PC expansion p1 by p2, and return the result in p3 (All arguments in double* format)  <a href="#aa6973a234d43c6216d3598e275d3cf96">More...</a><br/></td></tr>
<tr class="separator:aa6973a234d43c6216d3598e275d3cf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f9f79a631be44a68b8dd49ad10279b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ae9f9f79a631be44a68b8dd49ad10279b">Div</a> (const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p1, const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p2, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p3) const </td></tr>
<tr class="memdesc:ae9f9f79a631be44a68b8dd49ad10279b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide the PC expansion p1 by p2, and return the result in p3 (All arguments in <a class="el" href="classArray1D.html">Array1D&lt;double&gt;</a> format)  <a href="#ae9f9f79a631be44a68b8dd49ad10279b">More...</a><br/></td></tr>
<tr class="separator:ae9f9f79a631be44a68b8dd49ad10279b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8247f64545d6977c2b136d064b7d99f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ae8247f64545d6977c2b136d064b7d99f">StDv</a> (const double *p) const </td></tr>
<tr class="memdesc:ae8247f64545d6977c2b136d064b7d99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the standard deviation of PC expansion p in a double* format.  <a href="#ae8247f64545d6977c2b136d064b7d99f">More...</a><br/></td></tr>
<tr class="separator:ae8247f64545d6977c2b136d064b7d99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1445bd2c8921136fdcddbe3d76610f9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ac1445bd2c8921136fdcddbe3d76610f9">StDv</a> (const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p) const </td></tr>
<tr class="memdesc:ac1445bd2c8921136fdcddbe3d76610f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the standard deviation of PC expansion p (Argument in <a class="el" href="classArray1D.html">Array1D&lt;double&gt;</a> format)  <a href="#ac1445bd2c8921136fdcddbe3d76610f9">More...</a><br/></td></tr>
<tr class="separator:ac1445bd2c8921136fdcddbe3d76610f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af813471c8eb4128c9ce5f8d09bcfb6e1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#af813471c8eb4128c9ce5f8d09bcfb6e1">GetModesRMS</a> (const double *p) const </td></tr>
<tr class="memdesc:af813471c8eb4128c9ce5f8d09bcfb6e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the rms average of the PC coefficients (i.e. the square root of the average of the square of the PC coefficients, not taking into account any basis functions). (Arguments in double* format)  <a href="#af813471c8eb4128c9ce5f8d09bcfb6e1">More...</a><br/></td></tr>
<tr class="separator:af813471c8eb4128c9ce5f8d09bcfb6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbc5a8a6c34d0c436d8e10ed68076da"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a7cbc5a8a6c34d0c436d8e10ed68076da">GetModesRMS</a> (const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p) const </td></tr>
<tr class="memdesc:a7cbc5a8a6c34d0c436d8e10ed68076da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the rms average of the PC coefficients (i.e. the square root of the average of the square of the PC coefficients, not taking into account any basis functions). (Arguments in <a class="el" href="classArray1D.html">Array1D&lt;double&gt;</a> format)  <a href="#a7cbc5a8a6c34d0c436d8e10ed68076da">More...</a><br/></td></tr>
<tr class="separator:a7cbc5a8a6c34d0c436d8e10ed68076da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbee1aa5082a7366fe473036ba83842d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#abbee1aa5082a7366fe473036ba83842d">Derivative</a> (const double *p1, double *p2) const </td></tr>
<tr class="memdesc:abbee1aa5082a7366fe473036ba83842d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes derivatives of univariate PC given by coefficients p1 returns coefficient vector of the derivative in p2.  <a href="#abbee1aa5082a7366fe473036ba83842d">More...</a><br/></td></tr>
<tr class="separator:abbee1aa5082a7366fe473036ba83842d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5115eea512b650b85e6762afe9b9440a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a5115eea512b650b85e6762afe9b9440a">Derivative</a> (const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p1, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p2) const </td></tr>
<tr class="memdesc:a5115eea512b650b85e6762afe9b9440a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes derivatives of univariate PC given by coefficients p1 returns coefficient vector of the derivative in p2.  <a href="#a5115eea512b650b85e6762afe9b9440a">More...</a><br/></td></tr>
<tr class="separator:a5115eea512b650b85e6762afe9b9440a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17930f75a6b91ebcd34c0efef11e724d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a17930f75a6b91ebcd34c0efef11e724d">SeedBasisRandNumGen</a> (const int &amp;seed) const </td></tr>
<tr class="memdesc:a17930f75a6b91ebcd34c0efef11e724d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random sample generator functions.  <a href="#a17930f75a6b91ebcd34c0efef11e724d">More...</a><br/></td></tr>
<tr class="separator:a17930f75a6b91ebcd34c0efef11e724d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06e5fbf31a70669da19ee28692d0265"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ac06e5fbf31a70669da19ee28692d0265">DrawSampleSet</a> (const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;samples)</td></tr>
<tr class="memdesc:ac06e5fbf31a70669da19ee28692d0265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a set of samples from the PC expansion p, and return the result in the array samples. All arguments are in <a class="el" href="classArray1D.html">Array1D&lt;double&gt;</a> format The number of samples requested is assumed to be the size of the samples array.  <a href="#ac06e5fbf31a70669da19ee28692d0265">More...</a><br/></td></tr>
<tr class="separator:ac06e5fbf31a70669da19ee28692d0265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af217fb4344cf26bc2f3b212f686c0000"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#af217fb4344cf26bc2f3b212f686c0000">DrawSampleSet</a> (const double *p, double *samples, const int &amp;nSamples)</td></tr>
<tr class="memdesc:af217fb4344cf26bc2f3b212f686c0000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a set of samples from the PC expansion given in double* argument p, and return the result in double* array samples. The number of samples requested is the argument nSamples.  <a href="#af217fb4344cf26bc2f3b212f686c0000">More...</a><br/></td></tr>
<tr class="separator:af217fb4344cf26bc2f3b212f686c0000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ea0d982e84c54269de467def9ea5ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a65ea0d982e84c54269de467def9ea5ca">DrawSampleVar</a> (<a class="el" href="classArray2D.html">Array2D</a>&lt; double &gt; &amp;samples) const </td></tr>
<tr class="memdesc:a65ea0d982e84c54269de467def9ea5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a set of samples of the underlying germ random variable.  <a href="#a65ea0d982e84c54269de467def9ea5ca">More...</a><br/></td></tr>
<tr class="separator:a65ea0d982e84c54269de467def9ea5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821df40300160d5d2e0b11976ca10afc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a821df40300160d5d2e0b11976ca10afc">EvalPC</a> (const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;randVarSamples)</td></tr>
<tr class="memdesc:a821df40300160d5d2e0b11976ca10afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">PC evaluation functionalities.  <a href="#a821df40300160d5d2e0b11976ca10afc">More...</a><br/></td></tr>
<tr class="separator:a821df40300160d5d2e0b11976ca10afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531031aa2037aebc60446d494dd8970f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a531031aa2037aebc60446d494dd8970f">EvalPC</a> (const double *p, const double *randVarSamples)</td></tr>
<tr class="memdesc:a531031aa2037aebc60446d494dd8970f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the given PC expansion p, at the specified values of the random variables, randVarSamples. All arguments in const double* format.  <a href="#a531031aa2037aebc60446d494dd8970f">More...</a><br/></td></tr>
<tr class="separator:a531031aa2037aebc60446d494dd8970f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf513a3e88ed2842fa99a2c510f16a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a1cf513a3e88ed2842fa99a2c510f16a3">EvalPCAtCustPoints</a> (<a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;xch, <a class="el" href="classArray2D.html">Array2D</a>&lt; double &gt; &amp;custPoints, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;p)</td></tr>
<tr class="memdesc:a1cf513a3e88ed2842fa99a2c510f16a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the given PC expansion at given set of points with given coefficient vector and return the values in an 1D Array in the first argument.  <a href="#a1cf513a3e88ed2842fa99a2c510f16a3">More...</a><br/></td></tr>
<tr class="separator:a1cf513a3e88ed2842fa99a2c510f16a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc2cf2106a31b170bedd48be02bf179"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a8dc2cf2106a31b170bedd48be02bf179">EvalBasisAtCustPts</a> (const <a class="el" href="classArray2D.html">Array2D</a>&lt; double &gt; &amp;custPoints, <a class="el" href="classArray2D.html">Array2D</a>&lt; double &gt; &amp;psi)</td></tr>
<tr class="memdesc:a8dc2cf2106a31b170bedd48be02bf179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate Basis Functions at given points custPoints and return in the array psi.  <a href="#a8dc2cf2106a31b170bedd48be02bf179">More...</a><br/></td></tr>
<tr class="separator:a8dc2cf2106a31b170bedd48be02bf179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02aada88e0176ac83439a9c0ce587b6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a02aada88e0176ac83439a9c0ce587b6b">GalerkProjection</a> (const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;fcn, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;ck)</td></tr>
<tr class="memdesc:a02aada88e0176ac83439a9c0ce587b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Galerkin projection functionalities.  <a href="#a02aada88e0176ac83439a9c0ce587b6b">More...</a><br/></td></tr>
<tr class="separator:a02aada88e0176ac83439a9c0ce587b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2269cbf763ed3d5f396dbfc187f6772b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a2269cbf763ed3d5f396dbfc187f6772b">GalerkProjectionMC</a> (const <a class="el" href="classArray2D.html">Array2D</a>&lt; double &gt; &amp;x, const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;fcn, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;ck)</td></tr>
<tr class="memdesc:a2269cbf763ed3d5f396dbfc187f6772b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Galerkin Projection via Monte-Carlo integration.  <a href="#a2269cbf763ed3d5f396dbfc187f6772b">More...</a><br/></td></tr>
<tr class="separator:a2269cbf763ed3d5f396dbfc187f6772b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b0d9532eff6f625b5db8583354f9d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a99b0d9532eff6f625b5db8583354f9d5">ComputeOrders</a> (<a class="el" href="classArray1D.html">Array1D</a>&lt; int &gt; &amp;orders)</td></tr>
<tr class="memdesc:a99b0d9532eff6f625b5db8583354f9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiindex parsing functionalities.  <a href="#a99b0d9532eff6f625b5db8583354f9d5">More...</a><br/></td></tr>
<tr class="separator:a99b0d9532eff6f625b5db8583354f9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3149b3bac3e6b85e22c0f674e48fe8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a1a3149b3bac3e6b85e22c0f674e48fe8">ComputeEffDims</a> (<a class="el" href="classArray1D.html">Array1D</a>&lt; int &gt; &amp;effdim)</td></tr>
<tr class="memdesc:a1a3149b3bac3e6b85e22c0f674e48fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the effective dimensionality of each basis term, i.e., the number of dimensions that enter with a non-zero degree. also returns the maximal dimensionality among all basis terms.  <a href="#a1a3149b3bac3e6b85e22c0f674e48fe8">More...</a><br/></td></tr>
<tr class="separator:a1a3149b3bac3e6b85e22c0f674e48fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad385fc95c37e6b87603e676120d304be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ad385fc95c37e6b87603e676120d304be">EncodeMindex</a> (<a class="el" href="classArray1D.html">Array1D</a>&lt; <a class="el" href="classArray2D.html">Array2D</a>&lt; int &gt; &gt; &amp;sp_mindex)</td></tr>
<tr class="memdesc:ad385fc95c37e6b87603e676120d304be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode multiIndex into a 'sparse' format where the bases are ordered by their effective dimensionality. The i-th element in sp_mindex stores all the bases that have effective dimensionality equal to i. Also, only non-zero components are stored.  <a href="#ad385fc95c37e6b87603e676120d304be">More...</a><br/></td></tr>
<tr class="separator:ad385fc95c37e6b87603e676120d304be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb404d2de09f0d7ee83f6e50bcbcb02"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a1bb404d2de09f0d7ee83f6e50bcbcb02">ComputeMean</a> (<a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;coef)</td></tr>
<tr class="memdesc:a1bb404d2de09f0d7ee83f6e50bcbcb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moment/sensitivity extraction given coefficients.  <a href="#a1bb404d2de09f0d7ee83f6e50bcbcb02">More...</a><br/></td></tr>
<tr class="separator:a1bb404d2de09f0d7ee83f6e50bcbcb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62ead005359698c743b589d1a14bb64"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#aa62ead005359698c743b589d1a14bb64">ComputeVarFrac</a> (<a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;coef, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;varfrac)</td></tr>
<tr class="memdesc:aa62ead005359698c743b589d1a14bb64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the variance fractions of each basis term given coefficient array coef; returns the variance fractions in the array varfrac.  <a href="#aa62ead005359698c743b589d1a14bb64">More...</a><br/></td></tr>
<tr class="separator:aa62ead005359698c743b589d1a14bb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1c360cc8e305e50a1d418cc084550b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#abf1c360cc8e305e50a1d418cc084550b">ComputeMainSens</a> (<a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;coef, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;mainsens)</td></tr>
<tr class="memdesc:abf1c360cc8e305e50a1d418cc084550b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute main effect sensitivity (Sobol) indices given coefficient array coef; returns the indices in the array mainsens.  <a href="#abf1c360cc8e305e50a1d418cc084550b">More...</a><br/></td></tr>
<tr class="separator:abf1c360cc8e305e50a1d418cc084550b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc8071222615802f791f74ddb06f9a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a4dc8071222615802f791f74ddb06f9a7">ComputeTotSens</a> (<a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;coef, <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;totsens)</td></tr>
<tr class="memdesc:a4dc8071222615802f791f74ddb06f9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute total effect sensitivity (Sobol) indices given coefficient array coeff; returns the indices in the array totsens.  <a href="#a4dc8071222615802f791f74ddb06f9a7">More...</a><br/></td></tr>
<tr class="separator:a4dc8071222615802f791f74ddb06f9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b16eea0c145deed7a14fa02490883d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a96b16eea0c145deed7a14fa02490883d">ComputeJointSens</a> (<a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;coef, <a class="el" href="classArray2D.html">Array2D</a>&lt; double &gt; &amp;jointsens)</td></tr>
<tr class="memdesc:a96b16eea0c145deed7a14fa02490883d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute joint effect sensitivity (Sobol) indices given coefficient array coeff; returns the indices in the array jointsens.  <a href="#a96b16eea0c145deed7a14fa02490883d">More...</a><br/></td></tr>
<tr class="separator:a96b16eea0c145deed7a14fa02490883d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5efa220e7dbb32649510e17d7d331f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a7b5efa220e7dbb32649510e17d7d331f">SetVerbosity</a> (int verbosity)</td></tr>
<tr class="memdesc:a7b5efa220e7dbb32649510e17d7d331f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Other.  <a href="#a7b5efa220e7dbb32649510e17d7d331f">More...</a><br/></td></tr>
<tr class="separator:a7b5efa220e7dbb32649510e17d7d331f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06722aecd7b0201b4a4e5c743ea4045f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a06722aecd7b0201b4a4e5c743ea4045f">EvalNormSq</a> (<a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;normsq)</td></tr>
<tr class="memdesc:a06722aecd7b0201b4a4e5c743ea4045f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate norms-squared of all bases and return in the array normsq.  <a href="#a06722aecd7b0201b4a4e5c743ea4045f">More...</a><br/></td></tr>
<tr class="separator:a06722aecd7b0201b4a4e5c743ea4045f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17936e9efa3c0360f9b64689461d902c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a17936e9efa3c0360f9b64689461d902c">IsInDomain</a> (double x)</td></tr>
<tr class="memdesc:a17936e9efa3c0360f9b64689461d902c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the point x is in the PC domain.  <a href="#a17936e9efa3c0360f9b64689461d902c">More...</a><br/></td></tr>
<tr class="separator:a17936e9efa3c0360f9b64689461d902c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a8e0e38c02322f041d1aeaf674c556f94"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; int, <a class="el" href="classPCSet.html">PCSet</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a8e0e38c02322f041d1aeaf674c556f94">OMap_t</a></td></tr>
<tr class="memdesc:a8e0e38c02322f041d1aeaf674c556f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a map to connect integer indexes with pointers to this class.  <a href="#a8e0e38c02322f041d1aeaf674c556f94">More...</a><br/></td></tr>
<tr class="separator:a8e0e38c02322f041d1aeaf674c556f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a2fb3ca89c60c5846619763e398c99e56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a2fb3ca89c60c5846619763e398c99e56">PCSet</a> ()</td></tr>
<tr class="memdesc:a2fb3ca89c60c5846619763e398c99e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy default constructor, which should not be used as it is not well defined Therefore we make it private so it is not accessible.  <a href="#a2fb3ca89c60c5846619763e398c99e56">More...</a><br/></td></tr>
<tr class="separator:a2fb3ca89c60c5846619763e398c99e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa820cc9c4a6ffbc2e6622c038d398e50"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#aa820cc9c4a6ffbc2e6622c038d398e50">PCSet</a> (const <a class="el" href="classPCSet.html">PCSet</a> &amp;obj)</td></tr>
<tr class="memdesc:aa820cc9c4a6ffbc2e6622c038d398e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy copy constructor, which should not be used as it is currently not well defined. Therefore we make it private so it is not accessible.  <a href="#aa820cc9c4a6ffbc2e6622c038d398e50">More...</a><br/></td></tr>
<tr class="separator:aa820cc9c4a6ffbc2e6622c038d398e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893290d41a5ce15d7683c8e2148227ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a893290d41a5ce15d7683c8e2148227ea">ComputeMaxOrdPerDim</a> ()</td></tr>
<tr class="memdesc:a893290d41a5ce15d7683c8e2148227ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute maximal order per dimension and fill in the array maxOrdPerDim_.  <a href="#a893290d41a5ce15d7683c8e2148227ea">More...</a><br/></td></tr>
<tr class="separator:a893290d41a5ce15d7683c8e2148227ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849c4c41a7be1444c7255375874d7e8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a849c4c41a7be1444c7255375874d7e8e">Initialize</a> (const string ordertype)</td></tr>
<tr class="memdesc:a849c4c41a7be1444c7255375874d7e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization of the appropriate variables.  <a href="#a849c4c41a7be1444c7255375874d7e8e">More...</a><br/></td></tr>
<tr class="separator:a849c4c41a7be1444c7255375874d7e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1dadb97807074a8ed57e4d0670b287"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#afb1dadb97807074a8ed57e4d0670b287">InitISP</a> ()</td></tr>
<tr class="memdesc:afb1dadb97807074a8ed57e4d0670b287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize quadrature for computing triple products(ISP) and orthogonal projection(NISP)  <a href="#afb1dadb97807074a8ed57e4d0670b287">More...</a><br/></td></tr>
<tr class="separator:afb1dadb97807074a8ed57e4d0670b287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69645f83c82df9410be599af6cd670db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a69645f83c82df9410be599af6cd670db">InitNISP</a> ()</td></tr>
<tr class="memdesc:a69645f83c82df9410be599af6cd670db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize variables that are needed only in non-intrusive computations.  <a href="#a69645f83c82df9410be599af6cd670db">More...</a><br/></td></tr>
<tr class="separator:a69645f83c82df9410be599af6cd670db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a786a8581de6c1319ca0626e67d8db0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a3a786a8581de6c1319ca0626e67d8db0">EvalBasisProd3</a> ()</td></tr>
<tr class="memdesc:a3a786a8581de6c1319ca0626e67d8db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the expectation of product of three basis functions.  <a href="#a3a786a8581de6c1319ca0626e67d8db0">More...</a><br/></td></tr>
<tr class="separator:a3a786a8581de6c1319ca0626e67d8db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450f98440ba532f8e245b1b74825f151"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a450f98440ba532f8e245b1b74825f151">GMRESMatrixVectorProd</a> (const double *x, const double *a, double *y) const </td></tr>
<tr class="memdesc:a450f98440ba532f8e245b1b74825f151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual C++ implementation of the matric vector multiplication for GMRES for the division operation.  <a href="#a450f98440ba532f8e245b1b74825f151">More...</a><br/></td></tr>
<tr class="separator:a450f98440ba532f8e245b1b74825f151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b68ccfce8acbdf1b7f4359d91b13a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a90b68ccfce8acbdf1b7f4359d91b13a1">LogTaylor</a> (const double *p1, double *p2) const </td></tr>
<tr class="memdesc:a90b68ccfce8acbdf1b7f4359d91b13a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes natural logarithm using Taylor expansion: N p2 = ln(p1) = ln(p1Mean) + sum d n=1 n.  <a href="#a90b68ccfce8acbdf1b7f4359d91b13a1">More...</a><br/></td></tr>
<tr class="separator:a90b68ccfce8acbdf1b7f4359d91b13a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28904aa8bb4d4a5c54691cb71e5a1fdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a28904aa8bb4d4a5c54691cb71e5a1fdc">LogInt</a> (const double *p1, double *p2) const </td></tr>
<tr class="memdesc:a28904aa8bb4d4a5c54691cb71e5a1fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes natural logarithm by numerical integration: calculate p2=ln(p1) by integrating du=dx/x to get ln(x)  <a href="#a28904aa8bb4d4a5c54691cb71e5a1fdc">More...</a><br/></td></tr>
<tr class="separator:a28904aa8bb4d4a5c54691cb71e5a1fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91ba17346c301141fc479e74bd39167"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#af91ba17346c301141fc479e74bd39167">LogIntRhs</a> (realtype t, N_Vector y, N_Vector ydot, void *f_data) const </td></tr>
<tr class="memdesc:af91ba17346c301141fc479e74bd39167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates rhs necessary to compute natural logarithm via integration.  <a href="#af91ba17346c301141fc479e74bd39167">More...</a><br/></td></tr>
<tr class="separator:af91ba17346c301141fc479e74bd39167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7313c3937b7906a76344fc4a827ed9be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a7313c3937b7906a76344fc4a827ed9be">Check_CVflag</a> (void *flagvalue, const char *funcname, int opt) const </td></tr>
<tr class="memdesc:a7313c3937b7906a76344fc4a827ed9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check cvode return for errors.  <a href="#a7313c3937b7906a76344fc4a827ed9be">More...</a><br/></td></tr>
<tr class="separator:a7313c3937b7906a76344fc4a827ed9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:ade06bbd3d86cd7e27b70a10711d5dc6a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ade06bbd3d86cd7e27b70a10711d5dc6a">GMRESMatrixVectorProdWrapper</a> (int *n, double *x, double *y, int *nelt, int *ia, int *ja, double *a, int *obj)</td></tr>
<tr class="memdesc:ade06bbd3d86cd7e27b70a10711d5dc6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for Matrix-vector multiplication routine to be called by GMRES.  <a href="#ade06bbd3d86cd7e27b70a10711d5dc6a">More...</a><br/></td></tr>
<tr class="separator:ade06bbd3d86cd7e27b70a10711d5dc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8404374bcf4dbd01a0c4e2cba52f0c8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ad8404374bcf4dbd01a0c4e2cba52f0c8">GMRESPreCondWrapper</a> (int *n, double *r, double *z, int *nelt, int *ia, int *ja, double *a, int *obj, double *rwork, int *iwork)</td></tr>
<tr class="memdesc:ad8404374bcf4dbd01a0c4e2cba52f0c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for preconditioner routine to be called by GMRES.  <a href="#ad8404374bcf4dbd01a0c4e2cba52f0c8">More...</a><br/></td></tr>
<tr class="separator:ad8404374bcf4dbd01a0c4e2cba52f0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4e158bc9d58d417047a0cf0370a57d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#adf4e158bc9d58d417047a0cf0370a57d">LogIntRhsWrapper</a> (realtype t, N_Vector y, N_Vector ydot, void *f_data)</td></tr>
<tr class="memdesc:adf4e158bc9d58d417047a0cf0370a57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for LogIntRhs. The first component of f_data pointer carries an integer handle identifying the appropriate PC object.  <a href="#adf4e158bc9d58d417047a0cf0370a57d">More...</a><br/></td></tr>
<tr class="separator:adf4e158bc9d58d417047a0cf0370a57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a9f09cebea9bee0134a14dc773ee3d0d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a9f09cebea9bee0134a14dc773ee3d0d8">uqtkverbose_</a></td></tr>
<tr class="memdesc:a9f09cebea9bee0134a14dc773ee3d0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verbosity level.  <a href="#a9f09cebea9bee0134a14dc773ee3d0d8">More...</a><br/></td></tr>
<tr class="separator:a9f09cebea9bee0134a14dc773ee3d0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae919b21c301dd8ec2fc02d7d98894e45"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ae919b21c301dd8ec2fc02d7d98894e45">spType_</a></td></tr>
<tr class="memdesc:ae919b21c301dd8ec2fc02d7d98894e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">String indicator of ISP or NISP implementation type.  <a href="#ae919b21c301dd8ec2fc02d7d98894e45">More...</a><br/></td></tr>
<tr class="separator:ae919b21c301dd8ec2fc02d7d98894e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c9b38fd9511bbe98a63a411c536752"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a85c9b38fd9511bbe98a63a411c536752">pcType_</a></td></tr>
<tr class="memdesc:a85c9b38fd9511bbe98a63a411c536752"><td class="mdescLeft">&#160;</td><td class="mdescRight">String indicator of PC type.  <a href="#a85c9b38fd9511bbe98a63a411c536752">More...</a><br/></td></tr>
<tr class="separator:a85c9b38fd9511bbe98a63a411c536752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4a8dcadf49e8420ae75ab9e2438b76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPCBasis.html">PCBasis</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#aba4a8dcadf49e8420ae75ab9e2438b76">p_basis_</a></td></tr>
<tr class="memdesc:aba4a8dcadf49e8420ae75ab9e2438b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the class that defines the basis type and functions.  <a href="#aba4a8dcadf49e8420ae75ab9e2438b76">More...</a><br/></td></tr>
<tr class="separator:aba4a8dcadf49e8420ae75ab9e2438b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f45225f41d1cc5b003da6ebb3f89e4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a6f45225f41d1cc5b003da6ebb3f89e4c">order_</a></td></tr>
<tr class="memdesc:a6f45225f41d1cc5b003da6ebb3f89e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order of the PC representation.  <a href="#a6f45225f41d1cc5b003da6ebb3f89e4c">More...</a><br/></td></tr>
<tr class="separator:a6f45225f41d1cc5b003da6ebb3f89e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51ea1d90b9035a4fc4bc453487d00fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#af51ea1d90b9035a4fc4bc453487d00fd">maxorddim_</a></td></tr>
<tr class="memdesc:af51ea1d90b9035a4fc4bc453487d00fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximal order within all dimensions.  <a href="#af51ea1d90b9035a4fc4bc453487d00fd">More...</a><br/></td></tr>
<tr class="separator:af51ea1d90b9035a4fc4bc453487d00fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00bc59e863b9decdeb9c9484635e1c6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArray1D.html">Array1D</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a00bc59e863b9decdeb9c9484635e1c6f">maxOrders_</a></td></tr>
<tr class="memdesc:a00bc59e863b9decdeb9c9484635e1c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of maximum orders requested if custom(HDMR) ordering is requested.  <a href="#a00bc59e863b9decdeb9c9484635e1c6f">More...</a><br/></td></tr>
<tr class="separator:a00bc59e863b9decdeb9c9484635e1c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776033a814eaf814c8c17fc49bd13237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArray1D.html">Array1D</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a776033a814eaf814c8c17fc49bd13237">maxOrdPerDim_</a></td></tr>
<tr class="memdesc:a776033a814eaf814c8c17fc49bd13237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of maximum orders per dimension.  <a href="#a776033a814eaf814c8c17fc49bd13237">More...</a><br/></td></tr>
<tr class="separator:a776033a814eaf814c8c17fc49bd13237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f7bae49f3d49630212f974d44c0070"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ad6f7bae49f3d49630212f974d44c0070">nDim_</a></td></tr>
<tr class="memdesc:ad6f7bae49f3d49630212f974d44c0070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of stochastic dimensions (degrees of freedom) in the PC representation.  <a href="#ad6f7bae49f3d49630212f974d44c0070">More...</a><br/></td></tr>
<tr class="separator:ad6f7bae49f3d49630212f974d44c0070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0205ede2ee7f766d1ecf519b5b944565"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a0205ede2ee7f766d1ecf519b5b944565">nQuadPoints_</a></td></tr>
<tr class="memdesc:a0205ede2ee7f766d1ecf519b5b944565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of quadrature points used.  <a href="#a0205ede2ee7f766d1ecf519b5b944565">More...</a><br/></td></tr>
<tr class="separator:a0205ede2ee7f766d1ecf519b5b944565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849c897de8c61cc04069d75d0eb3bf0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a849c897de8c61cc04069d75d0eb3bf0d">nPCTerms_</a></td></tr>
<tr class="memdesc:a849c897de8c61cc04069d75d0eb3bf0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of terms in the PC expansions.  <a href="#a849c897de8c61cc04069d75d0eb3bf0d">More...</a><br/></td></tr>
<tr class="separator:a849c897de8c61cc04069d75d0eb3bf0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ab4962d0f3b40b1cfc4353b5ca708a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a32ab4962d0f3b40b1cfc4353b5ca708a">rTolTaylor_</a></td></tr>
<tr class="memdesc:a32ab4962d0f3b40b1cfc4353b5ca708a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative tolerance for Taylor series approximations.  <a href="#a32ab4962d0f3b40b1cfc4353b5ca708a">More...</a><br/></td></tr>
<tr class="separator:a32ab4962d0f3b40b1cfc4353b5ca708a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd503249a3b2301caa22a15ef1f2b238"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#abd503249a3b2301caa22a15ef1f2b238">maxTermTaylor_</a></td></tr>
<tr class="memdesc:abd503249a3b2301caa22a15ef1f2b238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max number of terms in Taylor series approximations.  <a href="#abd503249a3b2301caa22a15ef1f2b238">More...</a><br/></td></tr>
<tr class="separator:abd503249a3b2301caa22a15ef1f2b238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304e840c46b0b037ea23e474981edf56"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a304e840c46b0b037ea23e474981edf56">SMALL_</a></td></tr>
<tr class="memdesc:a304e840c46b0b037ea23e474981edf56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tolerance to avoid floating-point errors.  <a href="#a304e840c46b0b037ea23e474981edf56">More...</a><br/></td></tr>
<tr class="separator:a304e840c46b0b037ea23e474981edf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf656e494a49a0bcab3030e9e878ab6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a0cf656e494a49a0bcab3030e9e878ab6">rTolGMRESDiv_</a></td></tr>
<tr class="memdesc:a0cf656e494a49a0bcab3030e9e878ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">GMRES tolerance in <a class="el" href="classPCSet.html#aa6973a234d43c6216d3598e275d3cf96" title="Divide the PC expansion p1 by p2, and return the result in p3 (All arguments in double* format) ...">Div()</a>  <a href="#a0cf656e494a49a0bcab3030e9e878ab6">More...</a><br/></td></tr>
<tr class="separator:a0cf656e494a49a0bcab3030e9e878ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083209d181b3ac08c3acca16fcdc1b4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArray2D.html">Array2D</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a083209d181b3ac08c3acca16fcdc1b4f">psi_</a></td></tr>
<tr class="memdesc:a083209d181b3ac08c3acca16fcdc1b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array to store basis functions evaluated at quadrature points for each order: psi_(iqp,ipc) contains the value of the polynomial chaos ipc-th basis at the location of quadrature point iqp.  <a href="#a083209d181b3ac08c3acca16fcdc1b4f">More...</a><br/></td></tr>
<tr class="separator:a083209d181b3ac08c3acca16fcdc1b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae88efac22059261b0a8c43c34b2458"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a7ae88efac22059261b0a8c43c34b2458">psiSq_</a></td></tr>
<tr class="memdesc:a7ae88efac22059261b0a8c43c34b2458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array with the norms squared of the basis functions, corresponding to each term in the PC expansion.  <a href="#a7ae88efac22059261b0a8c43c34b2458">More...</a><br/></td></tr>
<tr class="separator:a7ae88efac22059261b0a8c43c34b2458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00349c9c11a12981a91371e69f190e19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArray2D.html">Array2D</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a00349c9c11a12981a91371e69f190e19">quadPoints_</a></td></tr>
<tr class="memdesc:a00349c9c11a12981a91371e69f190e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array to store quadrature points.  <a href="#a00349c9c11a12981a91371e69f190e19">More...</a><br/></td></tr>
<tr class="separator:a00349c9c11a12981a91371e69f190e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccbfe387b0c05b0d2ac49d2ff4512fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#abccbfe387b0c05b0d2ac49d2ff4512fa">quadWeights_</a></td></tr>
<tr class="memdesc:abccbfe387b0c05b0d2ac49d2ff4512fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array to store quadrature weights.  <a href="#abccbfe387b0c05b0d2ac49d2ff4512fa">More...</a><br/></td></tr>
<tr class="separator:abccbfe387b0c05b0d2ac49d2ff4512fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd68e481997bac4195b710aec6bb26d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArray2D.html">Array2D</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a7cd68e481997bac4195b710aec6bb26d">quadIndices_</a></td></tr>
<tr class="memdesc:a7cd68e481997bac4195b710aec6bb26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array to store quadrature point indexing; useful for nested rules.  <a href="#a7cd68e481997bac4195b710aec6bb26d">More...</a><br/></td></tr>
<tr class="separator:a7cd68e481997bac4195b710aec6bb26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba3c01d83730470ca7cb7960889a5a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArray2D.html">Array2D</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#afba3c01d83730470ca7cb7960889a5a8">multiIndex_</a></td></tr>
<tr class="memdesc:afba3c01d83730470ca7cb7960889a5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array to store multi-index: multiIndex_(ipc,idim) contains the order of the basis function associated with dimension idim, for the ipc-th term in the PC expansion.  <a href="#afba3c01d83730470ca7cb7960889a5a8">More...</a><br/></td></tr>
<tr class="separator:afba3c01d83730470ca7cb7960889a5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500f51e04c160fae8c3ce68ccd393c48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArray1D.html">Array1D</a>&lt; <a class="el" href="classArray1D.html">Array1D</a>&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a500f51e04c160fae8c3ce68ccd393c48">iProd2_</a></td></tr>
<tr class="memdesc:a500f51e04c160fae8c3ce68ccd393c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">i-indices of &lt;\Psi_i \Psi_j \Psi_k&gt; terms that are not zero, for all k  <a href="#a500f51e04c160fae8c3ce68ccd393c48">More...</a><br/></td></tr>
<tr class="separator:a500f51e04c160fae8c3ce68ccd393c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6215f570c7a3a8c63af53e20fb8256e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArray1D.html">Array1D</a>&lt; <a class="el" href="classArray1D.html">Array1D</a>&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a6215f570c7a3a8c63af53e20fb8256e3">jProd2_</a></td></tr>
<tr class="memdesc:a6215f570c7a3a8c63af53e20fb8256e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">j-indices of &lt;\Psi_i \Psi_j \Psi_k&gt; terms that are not zero, for all k  <a href="#a6215f570c7a3a8c63af53e20fb8256e3">More...</a><br/></td></tr>
<tr class="separator:a6215f570c7a3a8c63af53e20fb8256e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aff08ccd927f41cb2c481425688a7f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArray1D.html">Array1D</a>&lt; <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a0aff08ccd927f41cb2c481425688a7f1">psiIJKProd2_</a></td></tr>
<tr class="memdesc:a0aff08ccd927f41cb2c481425688a7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt;\Psi_i \Psi_j \Psi_k&gt; terms that are not zero, for all k  <a href="#a0aff08ccd927f41cb2c481425688a7f1">More...</a><br/></td></tr>
<tr class="separator:a0aff08ccd927f41cb2c481425688a7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35c0e250a24028d08e84e3ba1120210"><td class="memItemLeft" align="right" valign="top"><a class="el" href="PCSet_8h.html#a7ec503935215c038c44ef9fe72d08618">LogCompMethod</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ad35c0e250a24028d08e84e3ba1120210">logMethod_</a></td></tr>
<tr class="memdesc:ad35c0e250a24028d08e84e3ba1120210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for method to compute log: TaylorSeries or Integration.  <a href="#ad35c0e250a24028d08e84e3ba1120210">More...</a><br/></td></tr>
<tr class="separator:ad35c0e250a24028d08e84e3ba1120210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6bd8acf6746f2268877ae04bf0a1498"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ae6bd8acf6746f2268877ae04bf0a1498">CVmaxord_</a></td></tr>
<tr class="memdesc:ae6bd8acf6746f2268877ae04bf0a1498"><td class="mdescLeft">&#160;</td><td class="mdescRight">CVODE parameter: maximal order.  <a href="#ae6bd8acf6746f2268877ae04bf0a1498">More...</a><br/></td></tr>
<tr class="separator:ae6bd8acf6746f2268877ae04bf0a1498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7796881f244f7e4e985672445753c11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ab7796881f244f7e4e985672445753c11">CVmaxnumsteps_</a></td></tr>
<tr class="memdesc:ab7796881f244f7e4e985672445753c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">CVODE parameter: maximal number of steps.  <a href="#ab7796881f244f7e4e985672445753c11">More...</a><br/></td></tr>
<tr class="separator:ab7796881f244f7e4e985672445753c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cff821fd071d6a6b19a805b02ae6e4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a47cff821fd071d6a6b19a805b02ae6e4">CVinitstep_</a></td></tr>
<tr class="memdesc:a47cff821fd071d6a6b19a805b02ae6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">CVODE parameter: initial step size.  <a href="#a47cff821fd071d6a6b19a805b02ae6e4">More...</a><br/></td></tr>
<tr class="separator:a47cff821fd071d6a6b19a805b02ae6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ddb2ae75f977507aa0901f7fa1b60d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a81ddb2ae75f977507aa0901f7fa1b60d">CVmaxstep_</a></td></tr>
<tr class="memdesc:a81ddb2ae75f977507aa0901f7fa1b60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">CVODE parameter: maximal step size.  <a href="#a81ddb2ae75f977507aa0901f7fa1b60d">More...</a><br/></td></tr>
<tr class="separator:a81ddb2ae75f977507aa0901f7fa1b60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8da03486b3400eed05bc68a90991597"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ad8da03486b3400eed05bc68a90991597">CVrelt_</a></td></tr>
<tr class="memdesc:ad8da03486b3400eed05bc68a90991597"><td class="mdescLeft">&#160;</td><td class="mdescRight">CVODE parameter: relative tolerance.  <a href="#ad8da03486b3400eed05bc68a90991597">More...</a><br/></td></tr>
<tr class="separator:ad8da03486b3400eed05bc68a90991597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19ec73dc8d8d04881e6fa6aff0a5057"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ae19ec73dc8d8d04881e6fa6aff0a5057">CVabst_</a></td></tr>
<tr class="memdesc:ae19ec73dc8d8d04881e6fa6aff0a5057"><td class="mdescLeft">&#160;</td><td class="mdescRight">CVODE parameter: absolute tolerance.  <a href="#ae19ec73dc8d8d04881e6fa6aff0a5057">More...</a><br/></td></tr>
<tr class="separator:ae19ec73dc8d8d04881e6fa6aff0a5057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bb42190efb85348974e0e58572649d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#aa1bb42190efb85348974e0e58572649d">my_index_</a></td></tr>
<tr class="memdesc:aa1bb42190efb85348974e0e58572649d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of this class.  <a href="#aa1bb42190efb85348974e0e58572649d">More...</a><br/></td></tr>
<tr class="separator:aa1bb42190efb85348974e0e58572649d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416996d40aba72158daf4f406b468baf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a416996d40aba72158daf4f406b468baf">narg_</a></td></tr>
<tr class="memdesc:a416996d40aba72158daf4f406b468baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of free parameters to specify the basis.  <a href="#a416996d40aba72158daf4f406b468baf">More...</a><br/></td></tr>
<tr class="separator:a416996d40aba72158daf4f406b468baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae152590c93ef6322a6f06f2f27e141d5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#ae152590c93ef6322a6f06f2f27e141d5">alpha_</a></td></tr>
<tr class="memdesc:ae152590c93ef6322a6f06f2f27e141d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter alpha for PCs that require a parameter (GLG,SW,JB)  <a href="#ae152590c93ef6322a6f06f2f27e141d5">More...</a><br/></td></tr>
<tr class="separator:ae152590c93ef6322a6f06f2f27e141d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76232f9681a630104fbe060ea983933c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a76232f9681a630104fbe060ea983933c">beta_</a></td></tr>
<tr class="memdesc:a76232f9681a630104fbe060ea983933c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter beta for PCs that require two parameters (SW,JB)  <a href="#a76232f9681a630104fbe060ea983933c">More...</a><br/></td></tr>
<tr class="separator:a76232f9681a630104fbe060ea983933c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:aea25e50a3513d49fea83541b12c8b8d8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#aea25e50a3513d49fea83541b12c8b8d8">next_index_</a> = 0</td></tr>
<tr class="memdesc:aea25e50a3513d49fea83541b12c8b8d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">index of next object in map  <a href="#aea25e50a3513d49fea83541b12c8b8d8">More...</a><br/></td></tr>
<tr class="separator:aea25e50a3513d49fea83541b12c8b8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60818440b6eb734e051a3aaa986e62a7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classPCSet.html#a8e0e38c02322f041d1aeaf674c556f94">OMap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCSet.html#a60818440b6eb734e051a3aaa986e62a7">omap_</a> = NULL</td></tr>
<tr class="memdesc:a60818440b6eb734e051a3aaa986e62a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map to connect integer indexes with pointers to this class.  <a href="#a60818440b6eb734e051a3aaa986e62a7">More...</a><br/></td></tr>
<tr class="separator:a60818440b6eb734e051a3aaa986e62a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines and initializes PC basis function set and provides functions to manipulate PC expansions defined on this basis set. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a8e0e38c02322f041d1aeaf674c556f94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;int, <a class="el" href="classPCSet.html">PCSet</a>*&gt; <a class="el" href="classPCSet.html#a8e0e38c02322f041d1aeaf674c556f94">PCSet::OMap_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition of a map to connect integer indexes with pointers to this class. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a39330e506c58cbd1463b9c708b189f0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCSet::PCSet </td>
          <td>(</td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>sp_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>pc_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>betta</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor: initializes the PC basis set for the order, number of dimensions and type that are passed in. </p>
<p>Implementation type sp_type has three options "ISP" (intrusive methods), "NISP" (non-intrusive), or "NISPnoq" (non-intrusive without quadrature initialization) </p>
<dl class="section note"><dt>Note</dt><dd>alpha and betta are parameters only relevant for GLG, JB or SW chaoses </dd></dl>

</div>
</div>
<a class="anchor" id="ac8fd6a1bc00f546367cdfec248823306"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCSet::PCSet </td>
          <td>(</td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>sp_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>maxOrders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>pc_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>betta</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor: initializes the PC basis set ordered in an HDMR fashion given order per each HDMR rank (univariate, bivariate, etc...) </p>
<p>Implementation type sp_type has three options "ISP" (intrusive methods), "NISP" (non-intrusive), or "NISPnoq" (non-intrusive without quadrature initialization) </p>
<dl class="section note"><dt>Note</dt><dd>alpha and betta are parameters only relevant for GLG, JB or SW chaoses </dd></dl>

</div>
</div>
<a class="anchor" id="a52d1ad460b6a6aa5b44ccfaec70ac6c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCSet::PCSet </td>
          <td>(</td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>sp_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArray2D.html">Array2D</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>customMultiIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>pc_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>betta</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor: initializes the PC basis set for a given custom multiIndex. </p>
<p>Implementation type sp_type has three options "ISP" (intrusive methods), "NISP" (non-intrusive), or "NISPnoq" (non-intrusive without quadrature initialization) </p>
<dl class="section note"><dt>Note</dt><dd>alpha and betta are parameters only relevant for GLG, JB or SW chaoses </dd></dl>

</div>
</div>
<a class="anchor" id="ac1a3131cfebaca370b11fb9eb67f78e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCSet::~PCSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor: cleans up all memory and destroys object. </p>

</div>
</div>
<a class="anchor" id="a2fb3ca89c60c5846619763e398c99e56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PCSet::PCSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dummy default constructor, which should not be used as it is not well defined Therefore we make it private so it is not accessible. </p>
<dl class="section note"><dt>Note</dt><dd>All parameters are intialized to dummy values. </dd></dl>

</div>
</div>
<a class="anchor" id="aa820cc9c4a6ffbc2e6622c038d398e50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PCSet::PCSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPCSet.html">PCSet</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dummy copy constructor, which should not be used as it is currently not well defined. Therefore we make it private so it is not accessible. </p>
<dl class="section note"><dt>Note</dt><dd>I am not sure actually whether the initialization performed below is legal as it requires access to private data members of the class that is passed in. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af6bd139f0cf496b196fd3b8025f6aff9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Add </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add two PC expansions given by double* arguments p1 and p2, and return the result in p3. </p>

</div>
</div>
<a class="anchor" id="a111d6a52a3146aebb8a279156db4be2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add two PC expansions given by <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> arguments p1 and p2, and return the result in p3. </p>
<dl class="section note"><dt>Note</dt><dd>Requires the size of the arrays that are passed in to equal the number of PC terms </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>Do not require the output array size to be set initially. Instead, resize it inside the function. </dd></dl>

</div>
</div>
<a class="anchor" id="ae86122d77c17ed1eaac2db707437fad8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::AddInPlace </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add PC expansions given by double* argument p2 to p1 and return the result in p1. </p>

</div>
</div>
<a class="anchor" id="ae7ad18576354c5990199fe7584b07b53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::AddInPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add PC expansions given by <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p2 to p1 and return the result in p1. </p>
<dl class="section note"><dt>Note</dt><dd>Requires the size of the arrays that are passed in to equal the number of PC terms </dd></dl>

</div>
</div>
<a class="anchor" id="a7313c3937b7906a76344fc4a827ed9be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PCSet::Check_CVflag </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>flagvalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>funcname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check cvode return for errors. </p>

</div>
</div>
<a class="anchor" id="a1a3149b3bac3e6b85e22c0f674e48fe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PCSet::ComputeEffDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>effdim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the effective dimensionality of each basis term, i.e., the number of dimensions that enter with a non-zero degree. also returns the maximal dimensionality among all basis terms. </p>
<dl class="section note"><dt>Note</dt><dd>This is not the classical effective dimensionality, since all dimensions can still be involved. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000036">Todo:</a></b></dt><dd>There is no double* version of this function </dd></dl>

</div>
</div>
<a class="anchor" id="a96b16eea0c145deed7a14fa02490883d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::ComputeJointSens </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>coef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray2D.html">Array2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>jointsens</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute joint effect sensitivity (Sobol) indices given coefficient array coeff; returns the indices in the array jointsens. </p>
<dl class="section note"><dt>Note</dt><dd>jointsens will be populated as a strictly upper-diagonal matrix </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000042">Todo:</a></b></dt><dd>There is no double* version of this function </dd></dl>

</div>
</div>
<a class="anchor" id="abf1c360cc8e305e50a1d418cc084550b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::ComputeMainSens </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>coef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>mainsens</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute main effect sensitivity (Sobol) indices given coefficient array coef; returns the indices in the array mainsens. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000040">Todo:</a></b></dt><dd>There is no double* version of this function </dd></dl>

</div>
</div>
<a class="anchor" id="a893290d41a5ce15d7683c8e2148227ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::ComputeMaxOrdPerDim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute maximal order per dimension and fill in the array maxOrdPerDim_. </p>

</div>
</div>
<a class="anchor" id="a1bb404d2de09f0d7ee83f6e50bcbcb02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PCSet::ComputeMean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>coef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moment/sensitivity extraction given coefficients. </p>
<p>Compute the mean of the PC given coefficient array coef(seeking the zero-th order multiindex) </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000038">Todo:</a></b></dt><dd>There is no double* version of this function </dd></dl>

</div>
</div>
<a class="anchor" id="a99b0d9532eff6f625b5db8583354f9d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PCSet::ComputeOrders </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>orders</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiindex parsing functionalities. </p>
<p>Computes the order of each basis term and return it in the array orders, also returns the maximal order </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000035">Todo:</a></b></dt><dd>There is no double* version of this function </dd></dl>

</div>
</div>
<a class="anchor" id="a4dc8071222615802f791f74ddb06f9a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::ComputeTotSens </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>coef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>totsens</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute total effect sensitivity (Sobol) indices given coefficient array coeff; returns the indices in the array totsens. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000041">Todo:</a></b></dt><dd>There is no double* version of this function </dd></dl>

</div>
</div>
<a class="anchor" id="aa62ead005359698c743b589d1a14bb64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PCSet::ComputeVarFrac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>coef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>varfrac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the variance fractions of each basis term given coefficient array coef; returns the variance fractions in the array varfrac. </p>
<dl class="section note"><dt>Note</dt><dd>Also returns the variance </dd>
<dd>
The value for the zeroth order term has a special meaning: it is equal to mean^2/variance or (mean/std)^2. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000039">Todo:</a></b></dt><dd>There is no double* version of this function </dd></dl>

</div>
</div>
<a class="anchor" id="a806404a8a865705943171ad1ecbe599c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Copy </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy PC expansion p2 into p1 (i.e. p1 = p2). </p>
<p>All arguments in double* format. </p>

</div>
</div>
<a class="anchor" id="ad24c31c6032268cc3a4a4c6cea263113"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy PC expansion p2 into p1 (i.e. p1 = p2). </p>
<p>All arguments in Array format </p>
<dl class="section note"><dt>Note</dt><dd>Requires the size of the arrays that are passed in to equal the number of PC terms </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>Do not require the output array size to be set initially. Instead, resize it inside the function. </dd></dl>

</div>
</div>
<a class="anchor" id="abbee1aa5082a7366fe473036ba83842d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Derivative </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes derivatives of univariate PC given by coefficients p1 returns coefficient vector of the derivative in p2. </p>
<dl class="section note"><dt>Note</dt><dd>Makes use of intrusive computations on recursive formulae for derivatives </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000028">Todo:</a></b></dt><dd><p class="startdd">Supports LU and HG bases only </p>
<p class="enddd">Supports only for 1d PCs </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5115eea512b650b85e6762afe9b9440a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Derivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes derivatives of univariate PC given by coefficients p1 returns coefficient vector of the derivative in p2. </p>
<dl class="section note"><dt>Note</dt><dd>Makes use of intrusive computations on recursive formulae for derivatives </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000029">Todo:</a></b></dt><dd><p class="startdd">Supports LU and HG bases only </p>
<p class="enddd">Supports only for 1d PCs </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa6973a234d43c6216d3598e275d3cf96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Div </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide the PC expansion p1 by p2, and return the result in p3 (All arguments in double* format) </p>
<p>The "division" p3 = p1/p2 is performed by solving the system of equations p2*p3 = p1 for the unknown p3. </p>
<dl class="section note"><dt>Note</dt><dd>When GMRES is used to solve this system of equations (based on a preprocessor flag in the source code for this routine), a relative tolerance criterium is used that is set by default to 1.e-8, and can be changed with <a class="el" href="classPCSet.html#a0b8756858e2aa2168e9f0b38aa180d15" title="Set the relative tolerance for GMRES in Div routine. ">SetGMRESDivTolerance()</a>. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000024">Todo:</a></b></dt><dd>Remove duplication of data and parameters that was required for enforcing imposed "const" constraints on some of the arguments and the class data members when they are being passed to fortran. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9f9f79a631be44a68b8dd49ad10279b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Div </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide the PC expansion p1 by p2, and return the result in p3 (All arguments in <a class="el" href="classArray1D.html">Array1D&lt;double&gt;</a> format) </p>
<dl class="section note"><dt>Note</dt><dd>Requires the size of the arrays that are passed in to equal the number of PC terms </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000025">Todo:</a></b></dt><dd>Do not require the output array size to be set initially. Instead, resize it inside the function </dd></dl>

</div>
</div>
<a class="anchor" id="ac06e5fbf31a70669da19ee28692d0265"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::DrawSampleSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a set of samples from the PC expansion p, and return the result in the array samples. All arguments are in <a class="el" href="classArray1D.html">Array1D&lt;double&gt;</a> format The number of samples requested is assumed to be the size of the samples array. </p>
<dl class="section note"><dt>Note</dt><dd>The size of the array p that is passed in needs to equal the number of PC terms </dd></dl>

</div>
</div>
<a class="anchor" id="af217fb4344cf26bc2f3b212f686c0000"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::DrawSampleSet </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nSamples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a set of samples from the PC expansion given in double* argument p, and return the result in double* array samples. The number of samples requested is the argument nSamples. </p>

</div>
</div>
<a class="anchor" id="a65ea0d982e84c54269de467def9ea5ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::DrawSampleVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray2D.html">Array2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a set of samples of the underlying germ random variable. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000030">Todo:</a></b></dt><dd>There is no double* version of this function </dd></dl>

</div>
</div>
<a class="anchor" id="ad385fc95c37e6b87603e676120d304be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::EncodeMindex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; <a class="el" href="classArray2D.html">Array2D</a>&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>sp_mindex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode multiIndex into a 'sparse' format where the bases are ordered by their effective dimensionality. The i-th element in sp_mindex stores all the bases that have effective dimensionality equal to i. Also, only non-zero components are stored. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000037">Todo:</a></b></dt><dd>There is no double* version of this function </dd></dl>

</div>
</div>
<a class="anchor" id="a8dc2cf2106a31b170bedd48be02bf179"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::EvalBasisAtCustPts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArray2D.html">Array2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>custPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray2D.html">Array2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>psi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate Basis Functions at given points custPoints and return in the array psi. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000032">Todo:</a></b></dt><dd>There is no double* version of this function </dd></dl>

</div>
</div>
<a class="anchor" id="a3a786a8581de6c1319ca0626e67d8db0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::EvalBasisProd3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the expectation of product of three basis functions. </p>

</div>
</div>
<a class="anchor" id="a06722aecd7b0201b4a4e5c743ea4045f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::EvalNormSq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>normsq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate norms-squared of all bases and return in the array normsq. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000043">Todo:</a></b></dt><dd><p class="startdd">There is no double* version of this function </p>
<p class="enddd">Add a function that evaluates the analytic norms-squared </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="a821df40300160d5d2e0b11976ca10afc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PCSet::EvalPC </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>randVarSamples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PC evaluation functionalities. </p>
<p>Evaluate the given PC expansion p, at the specified values of the random variables, randVarSamples. All arguments in const <a class="el" href="classArray1D.html">Array1D&lt;double&gt;</a> format </p>
<dl class="section note"><dt>Note</dt><dd>The number of elements in p needs to match the number of terms in the PC expansions in this <a class="el" href="classPCSet.html" title="Defines and initializes PC basis function set and provides functions to manipulate PC expansions defi...">PCSet</a>. </dd>
<dd>
The number of elements in randVarSamples needs to match the number of dimensions in the PC expansion. </dd></dl>

</div>
</div>
<a class="anchor" id="a531031aa2037aebc60446d494dd8970f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PCSet::EvalPC </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>randVarSamples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the given PC expansion p, at the specified values of the random variables, randVarSamples. All arguments in const double* format. </p>
<dl class="section note"><dt>Note</dt><dd>The number of elements in p is assumed to match the number of terms in the PC expansions in this <a class="el" href="classPCSet.html" title="Defines and initializes PC basis function set and provides functions to manipulate PC expansions defi...">PCSet</a>. </dd>
<dd>
The number of elements in randVarSamples is assumed to match the number of dimensions in the PC expansion. </dd></dl>

</div>
</div>
<a class="anchor" id="a1cf513a3e88ed2842fa99a2c510f16a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::EvalPCAtCustPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>xch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray2D.html">Array2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>custPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the given PC expansion at given set of points with given coefficient vector and return the values in an 1D Array in the first argument. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000031">Todo:</a></b></dt><dd>There is no double* version of this function </dd></dl>

</div>
</div>
<a class="anchor" id="a755d8e136a80e6f6630c0416851a1234"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Exp </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take the exp() of the PC expansion given by double* argument p1, and return the result in p2. </p>
<p>Relies on Taylor series expansion: exp(x) = 1 + x + x^2/2! + x^3/3! + ... However, for efficiency and to avoid overflow, the terms are computed as d_i = d_{i-1}*x/i. Also, to reduce the number of terms needed in the series, we subtract the mean out of a random variable u as u = u_0 + (u-u_0) and exp(u) = exp(u_0)*exp(u-u_0), where exp(u_0) can be computed with the regular exp(double&amp; ) function </p>
<dl class="section note"><dt>Note</dt><dd>The Taylor series is truncated after a tolerance criterium is achieved on the relative error defined as the max absolute value of the PC coefficients in the last added term, divided by the mean of exp(p1). The tolerance is set to 1.e-6 by default and can be changed with <a class="el" href="classPCSet.html#ae00882eff713add35201706e2db6a9f4" title="Set relative tolerance for Taylor series approximations. ">SetTaylorTolerance()</a>. </dd>
<dd>
The maximum number of terms in the Taylor series is set by default to 500 and can be changed with <a class="el" href="classPCSet.html#ae7611a9a35ddac33913c953ed155b295" title="Set maximum number of terms in Taylor series approximations. ">SetTaylorTermsMax()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adac73e410463bfcbef9502e3639c4b45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take the exp() of the PC expansion given by <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p1, and return the result in p2. </p>
<dl class="section note"><dt>Note</dt><dd>Requires the size of the arrays that are passed in to equal the number of PC terms </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo:</a></b></dt><dd>Do not require the output array size to be set initially. Instead, resize it inside the function. </dd></dl>

</div>
</div>
<a class="anchor" id="a02aada88e0176ac83439a9c0ce587b6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::GalerkProjection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>fcn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>ck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Galerkin projection functionalities. </p>
<p>Performs (NISP) Galerkin projection, given function evaluations at quadrature points Returns in the coefficient vector in the second argument </p>
<dl class="section note"><dt>Note</dt><dd>User should make sure that the function HAS BEEN evaluated at the correct quadrature points by first extracting the quadrature points and evaluating the function externally </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000033">Todo:</a></b></dt><dd><p class="startdd">Overload this with forward function pointers </p>
<p class="enddd">There is no double* version of this function </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="a2269cbf763ed3d5f396dbfc187f6772b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::GalerkProjectionMC </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArray2D.html">Array2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>fcn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>ck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Galerkin Projection via Monte-Carlo integration. </p>
<dl class="section note"><dt>Note</dt><dd>User should make sure that the function HAS BEEN evaluated at the correct sampling points by first sampling the proper PC germ distribution and evaluating the function externally </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000034">Todo:</a></b></dt><dd><p class="startdd">Overload this with forward function pointers </p>
<p class="enddd">There is no double* version of this function </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="a6d4d605c58d5b049c9545bfe8b844457"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double PCSet::GetGMRESDivTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get relative tolerance for GMRES in Div routine. </p>

</div>
</div>
<a class="anchor" id="af813471c8eb4128c9ce5f8d09bcfb6e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PCSet::GetModesRMS </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the rms average of the PC coefficients (i.e. the square root of the average of the square of the PC coefficients, not taking into account any basis functions). (Arguments in double* format) </p>

</div>
</div>
<a class="anchor" id="a7cbc5a8a6c34d0c436d8e10ed68076da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PCSet::GetModesRMS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the rms average of the PC coefficients (i.e. the square root of the average of the square of the PC coefficients, not taking into account any basis functions). (Arguments in <a class="el" href="classArray1D.html">Array1D&lt;double&gt;</a> format) </p>
<dl class="section note"><dt>Note</dt><dd>Requires the size of the array that is passed in to equal the number of PC terms </dd></dl>

</div>
</div>
<a class="anchor" id="adf9229dd305d9f71ff4b1a0e6dbd22be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::GetMultiIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray2D.html">Array2D</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mindex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get and set variables/arrays inline. </p>
<p>Get the multiindex </p>

</div>
</div>
<a class="anchor" id="a669e201ab07ab7eac6dc308094e566e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PCSet::GetNDim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the PC dimensionality. </p>

</div>
</div>
<a class="anchor" id="aef80e902457132ce7ea94ccc78b64ea4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::GetNormSq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>normsq</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the norm-squared. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>this seems like a duplication, see below <a class="el" href="classPCSet.html#a652f515895963a080e436d062c839490" title="Get the basis polynomial norms-squared in an array class object psisq. ">GetPsiSq()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afbd3aad6872dd08178f28bca1f430839"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PCSet::GetNQuadPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of quadrature points. </p>

</div>
</div>
<a class="anchor" id="a7d9de62b98a30f02ca047090c1fa505a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PCSet::GetNumberPCTerms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of terms in a PC expansion of this order and dimension. </p>

</div>
</div>
<a class="anchor" id="a142e3f81b5baa75ed7a7276d3917897f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PCSet::GetOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the PC order. </p>

</div>
</div>
<a class="anchor" id="a7d584fff60be4daad2f807c86486d5b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::GetPsi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray2D.html">Array2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>psi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the values of the basis polynomials evaluated at the quadrature points. </p>

</div>
</div>
<a class="anchor" id="a927caa3132a7584b8dafe676a7e91cd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::GetPsi </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>psi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the polynomials evaluated at the quadrature points folded into a one-dimensional array psi. </p>

</div>
</div>
<a class="anchor" id="a652f515895963a080e436d062c839490"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::GetPsiSq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>psisq</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the basis polynomial norms-squared in an array class object psisq. </p>

</div>
</div>
<a class="anchor" id="a67f1c9e841ae254eff8f74a50d650443"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::GetPsiSq </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>psisq</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the basis polynomial norms-squared in a double* array psisq. </p>

</div>
</div>
<a class="anchor" id="a301434bdc272029f5891e4963b706824"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::GetQuadPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray2D.html">Array2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the quadrature points. </p>

</div>
</div>
<a class="anchor" id="ade53ff486c307f98b50b67242157e53f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::GetQuadPoints </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>quad</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the quadrature points folded into a one-dimensional array quad. </p>

</div>
</div>
<a class="anchor" id="a9fe0c28f6527f8f35bf48e217cf7a0a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::GetQuadPointsWeights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray2D.html">Array2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>wghts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the quadrature points and weights. </p>

</div>
</div>
<a class="anchor" id="aac9094c7385347b93131333a6d29e58c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::GetQuadWeights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>wghts</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the quadrature weights. </p>

</div>
</div>
<a class="anchor" id="a76bcba8c30387c5a840771e62a46c2a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::GetQuadWeights </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wghts</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the quadrature weights folded into a one-dimensional array wghts. </p>

</div>
</div>
<a class="anchor" id="a919ea124540fcbc82b851235eefe3e99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PCSet::GetTaylorTermsMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximum number of terms in Taylor series approximations. </p>

</div>
</div>
<a class="anchor" id="a7197a5164e9c3dbd549d76cdaab7b21a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double PCSet::GetTaylorTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get relative tolerance for Taylor series approximations. </p>

</div>
</div>
<a class="anchor" id="a450f98440ba532f8e245b1b74825f151"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::GMRESMatrixVectorProd </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Actual C++ implementation of the matric vector multiplication for GMRES for the division operation. </p>
<p>Given the structure of the problem, this boils down to the product between two PC variables. </p>

</div>
</div>
<a class="anchor" id="ade06bbd3d86cd7e27b70a10711d5dc6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PCSet::GMRESMatrixVectorProdWrapper </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nelt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ia</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ja</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for Matrix-vector multiplication routine to be called by GMRES. </p>
<p>As GMRES is a Fortran77 routine, this routine is defined as a static function. One of the function arguments (obj) was originally isym, a flag for matrix symmetry, but has been repurposed to carry an integer handle to identify this object. </p>
<dl class="section note"><dt>Note</dt><dd>The matrix vector product here comes down to a product between two PC expansions. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8404374bcf4dbd01a0c4e2cba52f0c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void PCSet::GMRESPreCondWrapper </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nelt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ia</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ja</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for preconditioner routine to be called by GMRES. </p>
<p>As GMRES is a Fortran77 routine, this routine is defined as a static function. One of the function arguments (obj) was originally isym, a flag for matrix symmetry, but has been repurposed to carry an integer handle to identify this object. </p>
<dl class="section note"><dt>Note</dt><dd>Since we currently do not use preconditioning, this routine does nothing. It is a place holder for future use. </dd></dl>

</div>
</div>
<a class="anchor" id="a849c4c41a7be1444c7255375874d7e8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Initialize </td>
          <td>(</td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>ordertype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization of the appropriate variables. </p>
<dl class="section note"><dt>Note</dt><dd>Intrusive implementation only works with TotalOrder multiindes </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000044">Todo:</a></b></dt><dd>Test and allow intrusive implementation with customized multiindices </dd></dl>

</div>
</div>
<a class="anchor" id="afb1dadb97807074a8ed57e4d0670b287"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::InitISP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize quadrature for computing triple products(ISP) and orthogonal projection(NISP) </p>
<p>Initialize variables that are needed only in intrusive computations </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>Need to find a better way to handle high-dimensional systems </dd></dl>

</div>
</div>
<a class="anchor" id="af8f5b2268e4d85e9aa9e139abbbc1192"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::InitMeanStDv </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intrusive arithmetics. </p>
<p>Initializes a PC expansion p in a double* format to have the same distribution as the underlying PC germ, but with a specified mean m and standard deviation s </p>
<dl class="section note"><dt>Note</dt><dd>This assumes that the zeroth order term is the first one in the multi-index - this assumption does not hold in general </dd>
<dd>
This function only holds for expansions with one stochastic dimension </dd>
<dd>
All existing coefficient values in p will be overwritten </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>Make this function work for general multi-indices, and for any number of stochastic dimensions </dd></dl>

</div>
</div>
<a class="anchor" id="a0dfc15c02421cffee65a6c491cf15e0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::InitMeanStDv </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a PC expansion p in <a class="el" href="classArray1D.html">Array1D&lt;double&gt;</a> format to have the same distribution as the underlying PC germ, but with a specified mean m and standard deviation s. </p>
<dl class="section note"><dt>Note</dt><dd>This assumes that the zeroth order term is the first one in the multi-index - this assumption does not hold in general </dd>
<dd>
This function only holds for expansions with one stochastic dimension </dd>
<dd>
All existing coefficient values in p will be overwritten </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Make this function work for general multi-indices, and for any number of stochastic dimensions </dd></dl>

</div>
</div>
<a class="anchor" id="a69645f83c82df9410be599af6cd670db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::InitNISP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize variables that are needed only in non-intrusive computations. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>Need to find a better way to handle high-dimensional systems </dd></dl>

</div>
</div>
<a class="anchor" id="a9472efb3ed768295727db014f9064191"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Inv </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the inverse of PC expansion given by double* argument p1, and return the result in p2. The inverse is computed using the division function. </p>

</div>
</div>
<a class="anchor" id="a2f97d12860187f9c66a27afdb67b4fd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Inv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the inverse of PC expansion given by <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p1, and return the result in <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p2. </p>
<dl class="section note"><dt>Note</dt><dd>Requires the size of the arrays that are passed in to equal the number of PC terms </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000023">Todo:</a></b></dt><dd>Do not require the output array size to be set initially. Instead, resize it inside the function </dd></dl>

</div>
</div>
<a class="anchor" id="a38ab2f1557b7969e3d1ababf09ae6711"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::IPow </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>ia</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate power ia (an integer number) of PC expansion given by double* argument p1, and return the result in p2. </p>

</div>
</div>
<a class="anchor" id="a79561ddc292cb669e72257b546ca5730"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::IPow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>ia</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate power ia (an integer number) of PC expansion given by <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p1, and return the result in <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p2. </p>
<dl class="section note"><dt>Note</dt><dd>Requires the size of the arrays that are passed in to equal the number of PC terms </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000022">Todo:</a></b></dt><dd>Do not require the output array size to be set initially. Instead, resize it inside the function </dd></dl>

</div>
</div>
<a class="anchor" id="a17936e9efa3c0360f9b64689461d902c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCSet::IsInDomain </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the point x is in the PC domain. </p>

</div>
</div>
<a class="anchor" id="a32f56c6441c1fde48b8faebfe1c7a0cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Log </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take the natural logarithm log() of the PC expansion given by double* argument p1, and return the result in p2. The logarithm is evaluated either via Taylor series or via integration depending on the value of parameter logMethod_. </p>

</div>
</div>
<a class="anchor" id="ab33722bcc9a2f8d363e75dabf2bad47f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take the natural logarithm, log(), of the PC expansion given by <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p1, and return the result in <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p2. </p>
<dl class="section note"><dt>Note</dt><dd>Requires the size of the arrays that are passed in to equal the number of PC terms </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000019">Todo:</a></b></dt><dd>Do not require the output array size to be set initially. Instead, resize it inside the function. </dd></dl>

</div>
</div>
<a class="anchor" id="af3cce271d6bacfc5f8b9d981da201e34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Log10 </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take the logarithm to base 10 of the PC expansion given by double* argument p1, and return the result in p2. </p>
<p>First use <a class="el" href="classPCSet.html#a32f56c6441c1fde48b8faebfe1c7a0cd" title="Take the natural logarithm log() of the PC expansion given by double* argument p1, and return the result in p2. The logarithm is evaluated either via Taylor series or via integration depending on the value of parameter logMethod_. ">Log()</a> to compute the natural logarithm and then divide it by log(10) </p>

</div>
</div>
<a class="anchor" id="ab1364fc8265d71c6ac6edc4df480acd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Log10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take the logarithm to base 10 of the PC expansion given by <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p1, and return the result in <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p2. </p>
<dl class="section note"><dt>Note</dt><dd>Requires the size of the arrays that are passed in to equal the number of PC terms </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000020">Todo:</a></b></dt><dd>Do not require the output array size to be set initially. Instead, resize it inside the function. </dd></dl>

</div>
</div>
<a class="anchor" id="a28904aa8bb4d4a5c54691cb71e5a1fdc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::LogInt </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes natural logarithm by numerical integration: calculate p2=ln(p1) by integrating du=dx/x to get ln(x) </p>

</div>
</div>
<a class="anchor" id="af91ba17346c301141fc479e74bd39167"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PCSet::LogIntRhs </td>
          <td>(</td>
          <td class="paramtype">realtype&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N_Vector&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N_Vector&#160;</td>
          <td class="paramname"><em>ydot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>f_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates rhs necessary to compute natural logarithm via integration. </p>

</div>
</div>
<a class="anchor" id="adf4e158bc9d58d417047a0cf0370a57d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int PCSet::LogIntRhsWrapper </td>
          <td>(</td>
          <td class="paramtype">realtype&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N_Vector&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N_Vector&#160;</td>
          <td class="paramname"><em>ydot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>f_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper for LogIntRhs. The first component of f_data pointer carries an integer handle identifying the appropriate PC object. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000045">Todo:</a></b></dt><dd>Why is this function a static int instead of static void? Should there be a return statement at the end? </dd></dl>

</div>
</div>
<a class="anchor" id="a90b68ccfce8acbdf1b7f4359d91b13a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::LogTaylor </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes natural logarithm using Taylor expansion: N p2 = ln(p1) = ln(p1Mean) + sum d n=1 n. </p>
<pre class="fragment">                  (n+1)
              (-1)       n            p1        
   where  d = ----     *x , and x = ------ - 1
           n   n                    p1Mean    
</pre><dl class="section note"><dt>Note</dt><dd>See Exp notes for info related to tolerance and maximum number of terms criteria for truncating the Taylor series </dd></dl>

</div>
</div>
<a class="anchor" id="a544ea1907eedb7a9fde90d5e0811d071"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Multiply </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply PC expansion p1 with scalar a and return the result in p2. All PCEs are in double* format. </p>

</div>
</div>
<a class="anchor" id="a0854bfa5e07dd64ee8faef4f5c620e39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply PC expansion p1 with scalar a and return the result in p2. All PCEs are in <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> format. </p>
<dl class="section note"><dt>Note</dt><dd>Requires the size of the arrays that are passed in to equal the number of PC terms </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>Do not require the output array size to be set initially. Instead, resize it inside the function. </dd></dl>

</div>
</div>
<a class="anchor" id="a5796339475eeac74f4233100ada3ae3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::MultiplyInPlace </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply PC expansions given by double* argument p1 with scalar a and return the result in p1. </p>

</div>
</div>
<a class="anchor" id="a4551a60a3de1135377beff722cc0f3b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::MultiplyInPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply PC expansions given by <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p1 with scalar a and return the result in p1. </p>
<dl class="section note"><dt>Note</dt><dd>Requires the size of the arrays that are passed in to equal the number of PC terms </dd></dl>

</div>
</div>
<a class="anchor" id="a7c402eb017c10844b0ae49e57ecf28b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Polyn </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>polycf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>npoly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a polynomial of PC that is given in double* argument p1. Polynomial coefficients are given in double* argument polycf of size npoly. The output PC is contained in double* argument p2. </p>
<dl class="section note"><dt>Note</dt><dd>Recursive algorithm is implemented. </dd></dl>

</div>
</div>
<a class="anchor" id="a676d08cc77c68365dbf59c62a29d6afe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Polyn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>polycf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a polynomial of PC that is given by <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p1. Polynomial coefficients are given in the <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument polycf. The output PC is contained in <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p2. </p>
<dl class="section note"><dt>Note</dt><dd>Requires the size of the arrays p1 and p2 to equal the number of PC terms </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd>Do not require the output array size to be set initially. Instead, resize it inside the function. </dd></dl>

</div>
</div>
<a class="anchor" id="a5128f399c1944f7819556072889713f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::PolynMulti </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>polycf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArray2D.html">Array2D</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArray2D.html">Array2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a multivariate polynomial of a set of PC inputs given by <a class="el" href="classArray2D.html" title="Stores data of any type T in a 2D array. ">Array2D</a> argument p1 (each column of p1 is a PC input). Polynomial coefficients are given in <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument polycf. Multiindex set for the multivariate polynomial is given in <a class="el" href="classArray2D.html" title="Stores data of any type T in a 2D array. ">Array2D</a> argument mindex. The output PC is contained in <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p2. </p>
<dl class="section note"><dt>Note</dt><dd>Requires the size of the array polycf to equal the first dimension of argument mindex </dd>
<dd>
Requires the size of the array p1 to equal (the number of PC terms) X (second dimension of argument mindex) </dd>
<dd>
Uses a recursive algorithm </dd>
<dd>
Out of convenience, this function so far is implemented for Array classes, not double* arrays. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd>A double* version should be added. </dd></dl>

</div>
</div>
<a class="anchor" id="ae82dcd8d6b29fa0b4916e80f6a9b2d32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::PrintMultiIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print information on the screen. </p>
<p>Print the multi-indices for all terms on the screen </p>

</div>
</div>
<a class="anchor" id="adebba2900a8ab2320c5f022bd97077be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::PrintMultiIndexNormSquared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For all terms, print their multi-index and norm^2 on the screen. </p>

</div>
</div>
<a class="anchor" id="afe35b9432ba5a7d112a7f6377f30a07f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Prod </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two PC expansions given by double* arguments p1 and p2, and return the result in p3. </p>

</div>
</div>
<a class="anchor" id="ace5527d93459cb8d756b094728890d24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Prod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multipy two PC expansions given by <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> arguments p1 and p2, and return the result in p3. </p>
<dl class="section note"><dt>Note</dt><dd>Requires the size of the arrays that are passed in to equal the number of PC terms </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>Do not require the output array size to be set initially. Instead, resize it inside the function. </dd></dl>

</div>
</div>
<a class="anchor" id="a209f150f95d36b398b5e6e6b5f6cb1c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::RPow </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate power a (a real number) of PC expansion given by double* argument p1, and return the result in p2. The power is computed as p1^a = exp(a*log(p1)), where log(p1) is evaluated either via Taylor series or via integration depending on the value of parameter logMethod_. </p>

</div>
</div>
<a class="anchor" id="ace215153ae1f103c3efc8a95e9ab3bd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::RPow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate power a (a real number) of PC expansion given by <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p1, and return the result in <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> argument p2. </p>
<dl class="section note"><dt>Note</dt><dd>Requires the size of the arrays that are passed in to equal the number of PC terms </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000021">Todo:</a></b></dt><dd>Do not require the output array size to be set initially. Instead, resize it inside the function </dd></dl>

</div>
</div>
<a class="anchor" id="a17930f75a6b91ebcd34c0efef11e724d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::SeedBasisRandNumGen </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Random sample generator functions. </p>
<p>Reseed the random number generator used for the sampling of the PC variables and expansions </p>

</div>
</div>
<a class="anchor" id="a0b8756858e2aa2168e9f0b38aa180d15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::SetGMRESDivTolerance </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>rTol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the relative tolerance for GMRES in Div routine. </p>

</div>
</div>
<a class="anchor" id="adb11850dfc7aaa0066f1dd84c1593378"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::SetLogCompMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="PCSet_8h.html#a7ec503935215c038c44ef9fe72d08618">LogCompMethod</a> &amp;&#160;</td>
          <td class="paramname"><em>logMethod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set method of computing the log function. </p>
<p>Use the argument TaylorSeries to select the Taylor series approach or Integration to select the integration method. </p>

</div>
</div>
<a class="anchor" id="a993d6c600aad5e25e0e0311598cbc047"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::SetQuadRule </td>
          <td>(</td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>grid_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>fs_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the quadrature rule. </p>
<p>Set the quadrature points by specifying a grid type, a full/sparse indicator, and an integer parameter</p>
<p>Full/sparse switch fs_type can be either 'full' or 'sparse' The parameter param is the number of points per dimension for full quadrature, and the level for sparse quadrature Options for grid_type are, besides the standard PC types, 'CC' (Clenshaw-Curtis), 'CCO' (Clenshaw-Curtis open), 'NC' (Newton-Cotes), 'NCO' (Newton-Cotes open), where open means that endpoints are expluded </p>
<dl class="section note"><dt>Note</dt><dd>'NC', 'NCO' quadratures are the same as uniformly spaced grids </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Need to improve it </dd></dl>

</div>
</div>
<a class="anchor" id="a78695a97e980e969d969e291e596d0f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::SetQuadRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQuad.html">Quad</a> &amp;&#160;</td>
          <td class="paramname"><em>quadRule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a custom quadrature rule by pointing to the corresponding object. </p>

</div>
</div>
<a class="anchor" id="ae7611a9a35ddac33913c953ed155b295"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::SetTaylorTermsMax </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>maxTerm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set maximum number of terms in Taylor series approximations. </p>

</div>
</div>
<a class="anchor" id="ae00882eff713add35201706e2db6a9f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::SetTaylorTolerance </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>rTol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set relative tolerance for Taylor series approximations. </p>

</div>
</div>
<a class="anchor" id="a7b5efa220e7dbb32649510e17d7d331f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::SetVerbosity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Other. </p>
<p>Set the verbosity level </p>
<dl class="section note"><dt>Note</dt><dd>Currently, the values of 0, 1 and 2 are implemented </dd></dl>

</div>
</div>
<a class="anchor" id="ae8247f64545d6977c2b136d064b7d99f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PCSet::StDv </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the standard deviation of PC expansion p in a double* format. </p>
<dl class="section note"><dt>Note</dt><dd>This assumes that the zeroth order term is the first one in the multi-index - this assumption does not hold in general </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000026">Todo:</a></b></dt><dd>Lift the assumption by looking for the constant term in the multiindex </dd></dl>

</div>
</div>
<a class="anchor" id="ac1445bd2c8921136fdcddbe3d76610f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PCSet::StDv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the standard deviation of PC expansion p (Argument in <a class="el" href="classArray1D.html">Array1D&lt;double&gt;</a> format) </p>
<dl class="section note"><dt>Note</dt><dd>This assumes that the zeroth order term is the first one in the multi-index - this assumption does not hold in general </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000027">Todo:</a></b></dt><dd>Lift the assumption by looking for the constant term in the multiindex </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For a more general implementation, see <a class="el" href="classPCSet.html#aa62ead005359698c743b589d1a14bb64" title="Compute the variance fractions of each basis term given coefficient array coef; returns the variance ...">ComputeVarFrac()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a09e0427bafd34e68cb55b966741780a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Subtract </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract PC expansion p2 from p1, and return the result in p3, with all arguments given as double*. </p>

</div>
</div>
<a class="anchor" id="a1792ca1daf265904f9c18f1a9859597a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::Subtract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract PC expansion p2 from p1, and return the result in p3, with all arguments given as <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> structures. </p>
<dl class="section note"><dt>Note</dt><dd>Requires the size of the arrays that are passed in to equal the number of PC terms </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>Do not require the output array size to be set initially. Instead, resize it inside the function. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3a7d92d80badff89e479232b531b8bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::SubtractInPlace </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract PC expansion p2 from p1, and return the result in p1, with all arguments given as double*. </p>

</div>
</div>
<a class="anchor" id="a269e4facd9387e1ad7cdfb2b9f64605a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCSet::SubtractInPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArray1D.html">Array1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract PC expansion p2 from p1, and return the result in p1, with all arguments given as <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> structures. </p>
<dl class="section note"><dt>Note</dt><dd>Requires the size of the arrays that are passed in to equal the number of PC terms </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ae152590c93ef6322a6f06f2f27e141d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double PCSet::alpha_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parameter alpha for PCs that require a parameter (GLG,SW,JB) </p>

</div>
</div>
<a class="anchor" id="a76232f9681a630104fbe060ea983933c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double PCSet::beta_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parameter beta for PCs that require two parameters (SW,JB) </p>

</div>
</div>
<a class="anchor" id="ae19ec73dc8d8d04881e6fa6aff0a5057"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double PCSet::CVabst_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>CVODE parameter: absolute tolerance. </p>

</div>
</div>
<a class="anchor" id="a47cff821fd071d6a6b19a805b02ae6e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double PCSet::CVinitstep_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>CVODE parameter: initial step size. </p>

</div>
</div>
<a class="anchor" id="ab7796881f244f7e4e985672445753c11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PCSet::CVmaxnumsteps_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>CVODE parameter: maximal number of steps. </p>

</div>
</div>
<a class="anchor" id="ae6bd8acf6746f2268877ae04bf0a1498"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PCSet::CVmaxord_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>CVODE parameter: maximal order. </p>

</div>
</div>
<a class="anchor" id="a81ddb2ae75f977507aa0901f7fa1b60d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double PCSet::CVmaxstep_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>CVODE parameter: maximal step size. </p>

</div>
</div>
<a class="anchor" id="ad8da03486b3400eed05bc68a90991597"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double PCSet::CVrelt_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>CVODE parameter: relative tolerance. </p>

</div>
</div>
<a class="anchor" id="a500f51e04c160fae8c3ce68ccd393c48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArray1D.html">Array1D</a>&lt;<a class="el" href="classArray1D.html">Array1D</a>&lt;int&gt; &gt; PCSet::iProd2_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>i-indices of &lt;\Psi_i \Psi_j \Psi_k&gt; terms that are not zero, for all k </p>
<dl class="section note"><dt>Note</dt><dd>Stored as a vector over k, with each element being a vector of i-indices itself </dd></dl>

</div>
</div>
<a class="anchor" id="a6215f570c7a3a8c63af53e20fb8256e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArray1D.html">Array1D</a>&lt;<a class="el" href="classArray1D.html">Array1D</a>&lt;int&gt; &gt; PCSet::jProd2_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>j-indices of &lt;\Psi_i \Psi_j \Psi_k&gt; terms that are not zero, for all k </p>
<dl class="section note"><dt>Note</dt><dd>Stored as a vector over k, with each element being a vector of j-indices itself </dd></dl>

</div>
</div>
<a class="anchor" id="ad35c0e250a24028d08e84e3ba1120210"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="PCSet_8h.html#a7ec503935215c038c44ef9fe72d08618">LogCompMethod</a> PCSet::logMethod_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag for method to compute log: TaylorSeries or Integration. </p>

</div>
</div>
<a class="anchor" id="af51ea1d90b9035a4fc4bc453487d00fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PCSet::maxorddim_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximal order within all dimensions. </p>

</div>
</div>
<a class="anchor" id="a00bc59e863b9decdeb9c9484635e1c6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArray1D.html">Array1D</a>&lt;int&gt; PCSet::maxOrders_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array of maximum orders requested if custom(HDMR) ordering is requested. </p>

</div>
</div>
<a class="anchor" id="a776033a814eaf814c8c17fc49bd13237"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArray1D.html">Array1D</a>&lt;int&gt; PCSet::maxOrdPerDim_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array of maximum orders per dimension. </p>

</div>
</div>
<a class="anchor" id="abd503249a3b2301caa22a15ef1f2b238"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PCSet::maxTermTaylor_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Max number of terms in Taylor series approximations. </p>

</div>
</div>
<a class="anchor" id="afba3c01d83730470ca7cb7960889a5a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArray2D.html">Array2D</a>&lt;int&gt; PCSet::multiIndex_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array to store multi-index: multiIndex_(ipc,idim) contains the order of the basis function associated with dimension idim, for the ipc-th term in the PC expansion. </p>

</div>
</div>
<a class="anchor" id="aa1bb42190efb85348974e0e58572649d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PCSet::my_index_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index of this class. </p>

</div>
</div>
<a class="anchor" id="a416996d40aba72158daf4f406b468baf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PCSet::narg_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of free parameters to specify the basis. </p>

</div>
</div>
<a class="anchor" id="ad6f7bae49f3d49630212f974d44c0070"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int PCSet::nDim_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of stochastic dimensions (degrees of freedom) in the PC representation. </p>

</div>
</div>
<a class="anchor" id="aea25e50a3513d49fea83541b12c8b8d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PCSet::next_index_ = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>index of next object in map </p>

</div>
</div>
<a class="anchor" id="a849c897de8c61cc04069d75d0eb3bf0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PCSet::nPCTerms_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total number of terms in the PC expansions. </p>

</div>
</div>
<a class="anchor" id="a0205ede2ee7f766d1ecf519b5b944565"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PCSet::nQuadPoints_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of quadrature points used. </p>

</div>
</div>
<a class="anchor" id="a60818440b6eb734e051a3aaa986e62a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPCSet.html#a8e0e38c02322f041d1aeaf674c556f94">PCSet::OMap_t</a> * PCSet::omap_ = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map to connect integer indexes with pointers to this class. </p>

</div>
</div>
<a class="anchor" id="a6f45225f41d1cc5b003da6ebb3f89e4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PCSet::order_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Order of the PC representation. </p>

</div>
</div>
<a class="anchor" id="aba4a8dcadf49e8420ae75ab9e2438b76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPCBasis.html">PCBasis</a>* PCSet::p_basis_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the class that defines the basis type and functions. </p>

</div>
</div>
<a class="anchor" id="a85c9b38fd9511bbe98a63a411c536752"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string PCSet::pcType_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String indicator of PC type. </p>

</div>
</div>
<a class="anchor" id="a083209d181b3ac08c3acca16fcdc1b4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArray2D.html">Array2D</a>&lt;double&gt; PCSet::psi_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array to store basis functions evaluated at quadrature points for each order: psi_(iqp,ipc) contains the value of the polynomial chaos ipc-th basis at the location of quadrature point iqp. </p>

</div>
</div>
<a class="anchor" id="a0aff08ccd927f41cb2c481425688a7f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArray1D.html">Array1D</a>&lt;<a class="el" href="classArray1D.html">Array1D</a>&lt;double&gt; &gt; PCSet::psiIJKProd2_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>&lt;\Psi_i \Psi_j \Psi_k&gt; terms that are not zero, for all k </p>
<dl class="section note"><dt>Note</dt><dd>Stored as a vector over k, with each element being a vector of &lt;\Psi_i \Psi_j \Psi_k&gt; values </dd></dl>

</div>
</div>
<a class="anchor" id="a7ae88efac22059261b0a8c43c34b2458"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArray1D.html">Array1D</a>&lt;double&gt; PCSet::psiSq_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array with the norms squared of the basis functions, corresponding to each term in the PC expansion. </p>

</div>
</div>
<a class="anchor" id="a7cd68e481997bac4195b710aec6bb26d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArray2D.html">Array2D</a>&lt;int&gt; PCSet::quadIndices_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array to store quadrature point indexing; useful for nested rules. </p>

</div>
</div>
<a class="anchor" id="a00349c9c11a12981a91371e69f190e19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArray2D.html">Array2D</a>&lt;double&gt; PCSet::quadPoints_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array to store quadrature points. </p>

</div>
</div>
<a class="anchor" id="abccbfe387b0c05b0d2ac49d2ff4512fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArray1D.html">Array1D</a>&lt;double&gt; PCSet::quadWeights_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array to store quadrature weights. </p>

</div>
</div>
<a class="anchor" id="a0cf656e494a49a0bcab3030e9e878ab6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double PCSet::rTolGMRESDiv_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>GMRES tolerance in <a class="el" href="classPCSet.html#aa6973a234d43c6216d3598e275d3cf96" title="Divide the PC expansion p1 by p2, and return the result in p3 (All arguments in double* format) ...">Div()</a> </p>

</div>
</div>
<a class="anchor" id="a32ab4962d0f3b40b1cfc4353b5ca708a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double PCSet::rTolTaylor_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relative tolerance for Taylor series approximations. </p>

</div>
</div>
<a class="anchor" id="a304e840c46b0b037ea23e474981edf56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double PCSet::SMALL_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tolerance to avoid floating-point errors. </p>

</div>
</div>
<a class="anchor" id="ae919b21c301dd8ec2fc02d7d98894e45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string PCSet::spType_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String indicator of ISP or NISP implementation type. </p>

</div>
</div>
<a class="anchor" id="a9f09cebea9bee0134a14dc773ee3d0d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PCSet::uqtkverbose_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verbosity level. </p>
<dl class="section note"><dt>Note</dt><dd>Currently the values of 0, 1 or 2 are implemented. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="PCSet_8h_source.html">PCSet.h</a></li>
<li><a class="el" href="PCSet_8cpp.html">PCSet.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 10 2014 14:40:26 for UQTk: Uncertainty Quantification Toolkit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
