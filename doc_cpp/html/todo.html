<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>UQTk: Uncertainty Quantification Toolkit: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">UQTk: Uncertainty Quantification Toolkit
   &#160;<span id="projectnumber">2.1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_todo000053"></a>Class <a class="el" href="classArray1D.html">Array1D&lt; T &gt;</a>  </dt>
<dd>double check copy constructor  </dd>
<dt><a class="anchor" id="_todo000054"></a>Member <a class="el" href="classArray1D.html#a601ac30b7c68e73f3523c9fbf32e9b1e">Array1D&lt; T &gt;::Resize</a>  (const size_t &amp;nx, const T &amp;t)</dt>
<dd>Write an implementation that is more closely follows the resize command in the vector class, which keeps the original elements and only initializes the new elements.  </dd>
<dt><a class="anchor" id="_todo000055"></a>Class <a class="el" href="classArray2D.html">Array2D&lt; T &gt;</a>  </dt>
<dd>Define copy constructor  </dd>
<dt><a class="anchor" id="_todo000056"></a>Member <a class="el" href="classArray2D.html#a7a4800edd705402c0a7cf8e47b7de519">Array2D&lt; T &gt;::Resize</a>  (const size_t &amp;nx, const size_t &amp;ny)</dt>
<dd>Write a better implementation that preserves the original data by copying it to a temporary array and putting the elements back where they were before. This would bring this resize() command more closely in line with vector::resize() function in the original vector class.  </dd>
<dt><a class="anchor" id="_todo000057"></a>Member <a class="el" href="classArray2D.html#abe5c898c0c3a87f1572d47043a466f0d">Array2D&lt; T &gt;::Resize</a>  (const size_t &amp;nx, const size_t &amp;ny, const T &amp;t)</dt>
<dd>Write an implementation that is more closely follows the resize command in the vector class, which keeps the original elements and only initializes the new elements.  </dd>
<dt><a class="anchor" id="_todo000058"></a>Class <a class="el" href="classArray3D.html">Array3D&lt; T &gt;</a>  </dt>
<dd><p class="startdd">Define copy constructor </p>
<p class="enddd">Several functions, e.g. insert/erase columns/rows, available in <a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a> and <a class="el" href="classArray2D.html" title="Stores data of any type T in a 2D array. ">Array2D</a>, are missing.  </p>
</dd>
<dt><a class="anchor" id="_todo000060"></a>Member <a class="el" href="classArray3D.html#ac1991b560439af5dabfb093c056cdbf7">Array3D&lt; T &gt;::Resize</a>  (const size_t &amp;nx, const size_t &amp;ny, const size_t &amp;nz, const T &amp;t)</dt>
<dd>Write an implementation that is more closely follows the resize command in the vector class, which keeps the original elements and only initializes the new elements.  </dd>
<dt><a class="anchor" id="_todo000059"></a>Member <a class="el" href="classArray3D.html#ac8640825b685d374f1b499c97891ba97">Array3D&lt; T &gt;::Resize</a>  (const size_t &amp;nx, const size_t &amp;ny, const size_t &amp;nz)</dt>
<dd>Write a better implementation that preserves the original data by copying it to a temporary array and putting the elements back where they were before. This would bring this resize() command more closely in line with vector::resize() function in the original vector class.  </dd>
<dt><a class="anchor" id="_todo000061"></a>File <a class="el" href="arraytools_8h.html">arraytools.h</a>  </dt>
<dd>Some functions are not optimal in terms of array access. They could be slower than MATLAB counterparts.  </dd>
<dt><a class="anchor" id="_todo000065"></a>Member <a class="el" href="arraytools_8h.html#a724bc6f7d45f20819ccd9bc991bfa667">copy</a>  (<a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;data_in, <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;data_out)</dt>
<dd>A simple data_out=data_in also should work  </dd>
<dt><a class="anchor" id="_todo000069"></a>File <a class="el" href="datafiles_8h.html">datafiles.h</a>  </dt>
<dd>Perhaps it makes sense to move these functions to array class  </dd>
<dt><a class="anchor" id="_todo000052"></a>Member <a class="el" href="fast__laplace_8h.html#a5b500875d236889dd7eec86ff081c1ee">FastLaplace</a>  (<a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;PHI, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;y, double &amp;sigma2, double eta, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;lambda_init, int adaptive, int optimal, double scale, int verbose, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;weights, <a class="el" href="classArray1D.html">Array1D&lt; int &gt;</a> &amp;used, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;errbars, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;basis, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;alpha, double &amp;lambda)</dt>
<dd>The array manipulations are not optimized - perhaps they need to be reconsidered using, say, fortran matrix-vector manipulation routines  </dd>
<dt><a class="anchor" id="_todo000073"></a>Member <a class="el" href="probability_8h.html#a7347fd91b04310145aa6d4e0d93aa92e">generate_normal_lhs</a>  (<a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;rvar, int zSeed)</dt>
<dd>LHS generation is far from optimal, it is quite slow  </dd>
<dt><a class="anchor" id="_todo000078"></a>Member <a class="el" href="pce__eval_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>  (int argc, char *argv[])</dt>
<dd><p class="startdd">Make the input arguments more transparent, i.e. what do they mean in different scenarios? </p>
<p class="enddd">Perhaps only compute simpler, l2 norm of the error without involving weights  </p>
</dd>
<dt><a class="anchor" id="_todo000051"></a>Member <a class="el" href="classMCMC.html#ab27d688a57269afa016b814d4c78fcaf">MCMC::evallogMVN_diag</a>  (<a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;x, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;mu, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;sig2)</dt>
<dd>Put sanity checks on dimensions  </dd>
<dt><a class="anchor" id="_todo000048"></a>Member <a class="el" href="classMCMC.html#a5e239a04741282b311142b5f7eadf7ff">MCMC::MCMC</a>  (double(*logPosterior)(<a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;, void *), void *postinfo)</dt>
<dd>This needs to be made more generic  </dd>
<dt><a class="anchor" id="_todo000049"></a>Member <a class="el" href="classMCMC.html#aa678cc0fc790eef401dcef06607b2200">MCMC::runChain</a>  (int ncalls, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;chstart)</dt>
<dd><p class="startdd">Specify defaults somewhere more transparently </p>
<p class="enddd">maybe only store tmode_(we save the full chain anyway)  </p>
</dd>
<dt><a class="anchor" id="_todo000063"></a>Member <a class="el" href="arraytools_8h.html#a15e19eff8fa613605e6657b182245637">merge</a>  (<a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;x, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;y, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;xy)</dt>
<dd>Proper size-checks needed  </dd>
<dt><a class="anchor" id="_todo000062"></a>Member <a class="el" href="arraytools_8h.html#a07bc9aa88ca36acf7d71216f53644f57">merge</a>  (<a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;x, <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;y, <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;xy)</dt>
<dd>Proper size-checks needed  </dd>
<dt><a class="anchor" id="_todo000064"></a>Member <a class="el" href="arraytools_8h.html#a969f6f5b3333a2d0c9c8ede900fb0fff">merge</a>  (<a class="el" href="classArray1D.html">Array1D&lt; int &gt;</a> &amp;x, <a class="el" href="classArray1D.html">Array1D&lt; int &gt;</a> &amp;y, <a class="el" href="classArray1D.html">Array1D&lt; int &gt;</a> &amp;xy)</dt>
<dd>Proper size-checks needed  </dd>
<dt><a class="anchor" id="_todo000067"></a>Member <a class="el" href="arraytools_8h.html#a35ad4639593a458533c127e8f2ae9529">moveArray1Dto2D</a>  (<a class="el" href="classArray1D.html">Array1D&lt; int &gt;</a> &amp;arr_1d, <a class="el" href="classArray2D.html">Array2D&lt; int &gt;</a> &amp;arr)</dt>
<dd>this duplicates the function array1Dto2D above  </dd>
<dt><a class="anchor" id="_todo000066"></a>Member <a class="el" href="arraytools_8h.html#a87f0c033ff7a15b5e1d711e148eb1579">moveArray1Dto2D</a>  (<a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;arr_1d, <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;arr)</dt>
<dd>this duplicates the function array1Dto2D above  </dd>
<dt><a class="anchor" id="_todo000070"></a>File <a class="el" href="multiindex_8h.html">multiindex.h</a>  </dt>
<dd>Multiindex could be a separate class and a part of core UQTk.  </dd>
<dt><a class="anchor" id="_todo000003"></a>Member <a class="el" href="classPCBasis.html#a92255e562e1a83b715a52801d6b7fa5f">PCBasis::EvalBasis</a>  (const double &amp;xi, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;basisEvals) const </dt>
<dd>Import the recursion coefficients in a more friendly fashion.  </dd>
<dt><a class="anchor" id="_todo000002"></a>Member <a class="el" href="classPCBasis.html#a7434a70f3b962f0e375a9a5edd9508ec">PCBasis::Init1dQuadPoints</a>  (int qdpts)</dt>
<dd>Come up with a smarter way to pick the number of quadrature points  </dd>
<dt><a class="anchor" id="_todo000001"></a>Member <a class="el" href="classPCBasis.html#a000d56b87ef6a80ee6dcf4c51a49066f">PCBasis::PCBasis</a>  (const string type="LU", const double alpha=0.0, const double betta=1.0, const int maxord=10)</dt>
<dd>At some point, the basis selection should probably be implemented in a more elegant way using base and inherited classes. For the time being, Hermite-Gaussian or Legendre-Uniform will probably be the most commonly used cases. The parameters alpha and betta are relevant only for GLG, SW and JB chaoses Maxord specifies the maximal order up to which the computations are performed  </dd>
<dt><a class="anchor" id="_todo000004"></a>Member <a class="el" href="classPCBasis.html#add6375d6c2e66eb0ea4ca938bd2875a6">PCBasis::rnstate_</a>  </dt>
<dd>need more functionalities to get/set this variable from user  </dd>
<dt><a class="anchor" id="_todo000071"></a>File <a class="el" href="pcmaps_8h.html">pcmaps.h</a>  </dt>
<dd>Perhaps use more robust tools, like dcdflib.  </dd>
<dt><a class="anchor" id="_todo000012"></a>Member <a class="el" href="classPCSet.html#a111d6a52a3146aebb8a279156db4be2d">PCSet::Add</a>  (const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p1, const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p2, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p3) const </dt>
<dd>Do not require the output array size to be set initially. Instead, resize it inside the function.  </dd>
<dt><a class="anchor" id="_todo000036"></a>Member <a class="el" href="classPCSet.html#a1a3149b3bac3e6b85e22c0f674e48fe8">PCSet::ComputeEffDims</a>  (<a class="el" href="classArray1D.html">Array1D&lt; int &gt;</a> &amp;effdim)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000042"></a>Member <a class="el" href="classPCSet.html#a96b16eea0c145deed7a14fa02490883d">PCSet::ComputeJointSens</a>  (<a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;coef, <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;jointsens)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000040"></a>Member <a class="el" href="classPCSet.html#abf1c360cc8e305e50a1d418cc084550b">PCSet::ComputeMainSens</a>  (<a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;coef, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;mainsens)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000038"></a>Member <a class="el" href="classPCSet.html#a1bb404d2de09f0d7ee83f6e50bcbcb02">PCSet::ComputeMean</a>  (<a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;coef)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000035"></a>Member <a class="el" href="classPCSet.html#a99b0d9532eff6f625b5db8583354f9d5">PCSet::ComputeOrders</a>  (<a class="el" href="classArray1D.html">Array1D&lt; int &gt;</a> &amp;orders)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000041"></a>Member <a class="el" href="classPCSet.html#a4dc8071222615802f791f74ddb06f9a7">PCSet::ComputeTotSens</a>  (<a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;coef, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;totsens)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000039"></a>Member <a class="el" href="classPCSet.html#aa62ead005359698c743b589d1a14bb64">PCSet::ComputeVarFrac</a>  (<a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;coef, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;varfrac)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000011"></a>Member <a class="el" href="classPCSet.html#ad24c31c6032268cc3a4a4c6cea263113">PCSet::Copy</a>  (<a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p1, const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p2) const </dt>
<dd>Do not require the output array size to be set initially. Instead, resize it inside the function.  </dd>
<dt><a class="anchor" id="_todo000028"></a>Member <a class="el" href="classPCSet.html#abbee1aa5082a7366fe473036ba83842d">PCSet::Derivative</a>  (const double *p1, double *p2) const </dt>
<dd><p class="startdd">Supports LU and HG bases only </p>
<p class="enddd">Supports only for 1d PCs  </p>
</dd>
<dt><a class="anchor" id="_todo000029"></a>Member <a class="el" href="classPCSet.html#a5115eea512b650b85e6762afe9b9440a">PCSet::Derivative</a>  (const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p1, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p2) const </dt>
<dd><p class="startdd">Supports LU and HG bases only </p>
<p class="enddd">Supports only for 1d PCs  </p>
</dd>
<dt><a class="anchor" id="_todo000024"></a>Member <a class="el" href="classPCSet.html#aa6973a234d43c6216d3598e275d3cf96">PCSet::Div</a>  (const double *p1, const double *p2, double *p3) const </dt>
<dd>Remove duplication of data and parameters that was required for enforcing imposed "const" constraints on some of the arguments and the class data members when they are being passed to fortran.  </dd>
<dt><a class="anchor" id="_todo000025"></a>Member <a class="el" href="classPCSet.html#ae9f9f79a631be44a68b8dd49ad10279b">PCSet::Div</a>  (const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p1, const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p2, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p3) const </dt>
<dd>Do not require the output array size to be set initially. Instead, resize it inside the function  </dd>
<dt><a class="anchor" id="_todo000030"></a>Member <a class="el" href="classPCSet.html#a65ea0d982e84c54269de467def9ea5ca">PCSet::DrawSampleVar</a>  (<a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;samples) const </dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000037"></a>Member <a class="el" href="classPCSet.html#ad385fc95c37e6b87603e676120d304be">PCSet::EncodeMindex</a>  (<a class="el" href="classArray1D.html" title="Stores data of any type T in a 1D array. ">Array1D</a>&lt; <a class="el" href="classArray2D.html">Array2D&lt; int &gt;</a> &gt; &amp;sp_mindex)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000032"></a>Member <a class="el" href="classPCSet.html#a8dc2cf2106a31b170bedd48be02bf179">PCSet::EvalBasisAtCustPts</a>  (const <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;custPoints, <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;psi)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000043"></a>Member <a class="el" href="classPCSet.html#a06722aecd7b0201b4a4e5c743ea4045f">PCSet::EvalNormSq</a>  (<a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;normsq)</dt>
<dd><p class="startdd">There is no double* version of this function </p>
<p class="enddd">Add a function that evaluates the analytic norms-squared  </p>
</dd>
<dt><a class="anchor" id="_todo000031"></a>Member <a class="el" href="classPCSet.html#a1cf513a3e88ed2842fa99a2c510f16a3">PCSet::EvalPCAtCustPoints</a>  (<a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;xch, <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;custPoints, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p)</dt>
<dd>There is no double* version of this function  </dd>
<dt><a class="anchor" id="_todo000018"></a>Member <a class="el" href="classPCSet.html#adac73e410463bfcbef9502e3639c4b45">PCSet::Exp</a>  (const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p1, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p2) const </dt>
<dd>Do not require the output array size to be set initially. Instead, resize it inside the function.  </dd>
<dt><a class="anchor" id="_todo000033"></a>Member <a class="el" href="classPCSet.html#a02aada88e0176ac83439a9c0ce587b6b">PCSet::GalerkProjection</a>  (const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;fcn, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;ck)</dt>
<dd><p class="startdd">Overload this with forward function pointers </p>
<p class="enddd">There is no double* version of this function  </p>
</dd>
<dt><a class="anchor" id="_todo000034"></a>Member <a class="el" href="classPCSet.html#a2269cbf763ed3d5f396dbfc187f6772b">PCSet::GalerkProjectionMC</a>  (const <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;x, const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;fcn, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;ck)</dt>
<dd><p class="startdd">Overload this with forward function pointers </p>
<p class="enddd">There is no double* version of this function  </p>
</dd>
<dt><a class="anchor" id="_todo000008"></a>Member <a class="el" href="classPCSet.html#aef80e902457132ce7ea94ccc78b64ea4">PCSet::GetNormSq</a>  (<a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;normsq) const </dt>
<dd>this seems like a duplication, see below GetPsiSq()  </dd>
<dt><a class="anchor" id="_todo000044"></a>Member <a class="el" href="classPCSet.html#a849c4c41a7be1444c7255375874d7e8e">PCSet::Initialize</a>  (const string ordertype)</dt>
<dd>Test and allow intrusive implementation with customized multiindices  </dd>
<dt><a class="anchor" id="_todo000005"></a>Member <a class="el" href="classPCSet.html#afb1dadb97807074a8ed57e4d0670b287">PCSet::InitISP</a>  ()</dt>
<dd>Need to find a better way to handle high-dimensional systems  </dd>
<dt><a class="anchor" id="_todo000010"></a>Member <a class="el" href="classPCSet.html#a0dfc15c02421cffee65a6c491cf15e0a">PCSet::InitMeanStDv</a>  (const double &amp;m, const double &amp;s, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p) const </dt>
<dd>Make this function work for general multi-indices, and for any number of stochastic dimensions  </dd>
<dt><a class="anchor" id="_todo000009"></a>Member <a class="el" href="classPCSet.html#af8f5b2268e4d85e9aa9e139abbbc1192">PCSet::InitMeanStDv</a>  (const double &amp;m, const double &amp;s, double *p) const </dt>
<dd>Make this function work for general multi-indices, and for any number of stochastic dimensions  </dd>
<dt><a class="anchor" id="_todo000006"></a>Member <a class="el" href="classPCSet.html#a69645f83c82df9410be599af6cd670db">PCSet::InitNISP</a>  ()</dt>
<dd>Need to find a better way to handle high-dimensional systems  </dd>
<dt><a class="anchor" id="_todo000023"></a>Member <a class="el" href="classPCSet.html#a2f97d12860187f9c66a27afdb67b4fd2">PCSet::Inv</a>  (const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p1, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p2) const </dt>
<dd>Do not require the output array size to be set initially. Instead, resize it inside the function  </dd>
<dt><a class="anchor" id="_todo000022"></a>Member <a class="el" href="classPCSet.html#a79561ddc292cb669e72257b546ca5730">PCSet::IPow</a>  (const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p1, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p2, const int &amp;ia) const </dt>
<dd>Do not require the output array size to be set initially. Instead, resize it inside the function  </dd>
<dt><a class="anchor" id="_todo000019"></a>Member <a class="el" href="classPCSet.html#ab33722bcc9a2f8d363e75dabf2bad47f">PCSet::Log</a>  (const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p1, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p2) const </dt>
<dd>Do not require the output array size to be set initially. Instead, resize it inside the function.  </dd>
<dt><a class="anchor" id="_todo000020"></a>Member <a class="el" href="classPCSet.html#ab1364fc8265d71c6ac6edc4df480acd2">PCSet::Log10</a>  (const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p1, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p2) const </dt>
<dd>Do not require the output array size to be set initially. Instead, resize it inside the function.  </dd>
<dt><a class="anchor" id="_todo000045"></a>Member <a class="el" href="classPCSet.html#adf4e158bc9d58d417047a0cf0370a57d">PCSet::LogIntRhsWrapper</a>  (realtype t, N_Vector y, N_Vector ydot, void *f_data)</dt>
<dd>Why is this function a static int instead of static void? Should there be a return statement at the end?  </dd>
<dt><a class="anchor" id="_todo000013"></a>Member <a class="el" href="classPCSet.html#a0854bfa5e07dd64ee8faef4f5c620e39">PCSet::Multiply</a>  (const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p1, const double &amp;a, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p2) const </dt>
<dd>Do not require the output array size to be set initially. Instead, resize it inside the function.  </dd>
<dt><a class="anchor" id="_todo000016"></a>Member <a class="el" href="classPCSet.html#a676d08cc77c68365dbf59c62a29d6afe">PCSet::Polyn</a>  (const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;polycf, const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p1, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p2) const </dt>
<dd>Do not require the output array size to be set initially. Instead, resize it inside the function.  </dd>
<dt><a class="anchor" id="_todo000017"></a>Member <a class="el" href="classPCSet.html#a5128f399c1944f7819556072889713f1">PCSet::PolynMulti</a>  (const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;polycf, const <a class="el" href="classArray2D.html">Array2D&lt; int &gt;</a> &amp;mindex, const <a class="el" href="classArray2D.html">Array2D&lt; double &gt;</a> &amp;p1, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p2) const </dt>
<dd>A double* version should be added.  </dd>
<dt><a class="anchor" id="_todo000015"></a>Member <a class="el" href="classPCSet.html#ace5527d93459cb8d756b094728890d24">PCSet::Prod</a>  (const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p1, const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p2, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p3) const </dt>
<dd>Do not require the output array size to be set initially. Instead, resize it inside the function.  </dd>
<dt><a class="anchor" id="_todo000021"></a>Member <a class="el" href="classPCSet.html#ace215153ae1f103c3efc8a95e9ab3bd7">PCSet::RPow</a>  (const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p1, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p2, const double &amp;a) const </dt>
<dd>Do not require the output array size to be set initially. Instead, resize it inside the function  </dd>
<dt><a class="anchor" id="_todo000007"></a>Member <a class="el" href="classPCSet.html#a993d6c600aad5e25e0e0311598cbc047">PCSet::SetQuadRule</a>  (const string grid_type, const string fs_type, int param)</dt>
<dd>Need to improve it  </dd>
<dt><a class="anchor" id="_todo000027"></a>Member <a class="el" href="classPCSet.html#ac1445bd2c8921136fdcddbe3d76610f9">PCSet::StDv</a>  (const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p) const </dt>
<dd>Lift the assumption by looking for the constant term in the multiindex  </dd>
<dt><a class="anchor" id="_todo000026"></a>Member <a class="el" href="classPCSet.html#ae8247f64545d6977c2b136d064b7d99f">PCSet::StDv</a>  (const double *p) const </dt>
<dd>Lift the assumption by looking for the constant term in the multiindex  </dd>
<dt><a class="anchor" id="_todo000014"></a>Member <a class="el" href="classPCSet.html#a1792ca1daf265904f9c18f1a9859597a">PCSet::Subtract</a>  (const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p1, const <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p2, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;p3) const </dt>
<dd>Do not require the output array size to be set initially. Instead, resize it inside the function.  </dd>
<dt><a class="anchor" id="_todo000072"></a>File <a class="el" href="probability_8h.html">probability.h</a>  </dt>
<dd>There shuold be a RNG class as a part of core UQTk - most of these functions will fit there.  </dd>
<dt><a class="anchor" id="_todo000047"></a>Member <a class="el" href="classQuad.html#a5df24a12fdbed7e3d4d9d28e0677c923">Quad::create1DRule_pdf</a>  (<a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;qdpts, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;wghts, int ngr, double a, double b)</dt>
<dd>Recursive coefficients are given in a file 'ab.dat'; will need to make this more friendly  </dd>
<dt><a class="anchor" id="_todo000046"></a>Member <a class="el" href="classQuad.html#a1a59877017927a85753957a0d0856365">Quad::nextLevel</a>  ()</dt>
<dd>Comment this better  </dd>
<dt><a class="anchor" id="_todo000076"></a>Member <a class="el" href="XMLreader_8h.html#aa4fca400ddeaaa8bfe3068f030689714">readXMLChainInput</a>  (RefPtr&lt; XMLElement &gt; xmlTree, <a class="el" href="classMCMC.html" title="Markov Chain Monte Carlo class. Implemented single-site and adaptive MCMC algorithms. ">MCMC</a> *pmchain, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;chstart, int *nsteps, <a class="el" href="classArray1D.html">Array1D&lt; int &gt;</a> &amp;chainParamInd, <a class="el" href="classArray1D.html">Array1D&lt; string &gt;</a> &amp;priortype, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;priorparam1, <a class="el" href="classArray1D.html">Array1D&lt; double &gt;</a> &amp;priorparam2)</dt>
<dd>Put proper checks on the file sizes  </dd>
<dt><a class="anchor" id="_todo000068"></a>Member <a class="el" href="arraytools_8h.html#a4ad5a87ae0b31ba9e14e84fc0de0199e">setdiff_s</a>  (<a class="el" href="classArray1D.html">Array1D&lt; int &gt;</a> &amp;A, <a class="el" href="classArray1D.html">Array1D&lt; int &gt;</a> &amp;B, <a class="el" href="classArray1D.html">Array1D&lt; int &gt;</a> &amp;C)</dt>
<dd>In future, this should sort A too and replace setdiff  </dd>
<dt><a class="anchor" id="_todo000074"></a>Member <a class="el" href="probability_8h.html#a9b0b0f9188bac9f84cc3d0316cfbb261">shell_sort</a>  (int *a, int n)</dt>
<dd>move and merge this into <a class="el" href="arraytools_8h.html">arraytools.h</a> tools  </dd>
<dt><a class="anchor" id="_todo000075"></a>Class <a class="el" href="structTantrum.html">Tantrum</a>  </dt>
<dd>Build in more smarts for tracing error etc.  </dd>
<dt><a class="anchor" id="_todo000079"></a>Member <a class="el" href="pce__rv_8cpp.html#ad876cdd1a72412cf2e0d2fcde266dd9a">usage</a>  ()</dt>
<dd>Add more detailed information on options. E.g. what are the different options for type of random variable? When does the order need to be specified? </dd>
</dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 10 2014 14:40:26 for UQTk: Uncertainty Quantification Toolkit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
